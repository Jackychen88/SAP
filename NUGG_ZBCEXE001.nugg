<?xml version="1.0" encoding="utf-8"?>
<nugget name="ZBCEXE001">
 <PROG NAME="ZBCEXE001" VARCL="X" SUBC="1" RMAND="008" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="1">
    <textElement ID="R" ENTRY="ZBCEXE001" LENGTH="9 "/>
   </language>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="ZBCEXE001" LENGTH="9 "/>
   </language>
  </textPool>
  <dynpros>
   <dynpro PROG="ZBCEXE001" DNUM="0100" FNUM="0100" BZMX="36 " BZBR="165 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="36 " NOCO="165 " VALP="0 " CUAN="G" SPRA="E" DTEXT="MAINTAIN">
    <dynprofield FNAM="%#AUTOTEXT001" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0A" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="TABLE NAME" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="DD02L-TABNAME" DIDX="000D" FLG1="A1" FLG2="00" FLG3="80" FMB1="00" FMB2="18" LENG="1E" LINE="01" COLN="0D" LANF="00" LBLK="00" LREP="00" PAID="DTB" TYPE="CHAR" DMAC="DD_DBTB_16" ITYP="C" AGLT="3C" ADEZ="00" STXT="______________________________" RES1="                                       00"/>
    <dynprofield FNAM="G_DDTEXT" DIDX="0028" FLG1="81" FLG2="00" FLG3="80" FMB1="30" FMB2="00" LENG="3C" LINE="01" COLN="1B" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="____________________________________________________________"/>
    <dynprofield FNAM="DATA_TOTAL_COUNT" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="34" FMB2="00" LENG="11" LINE="01" COLN="47" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="DATA TOTAL COUNT:"/>
    <dynprofield FNAM="G_GT_COUNT" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="34" FMB2="00" LENG="0B" LINE="01" COLN="59" LANF="00" LBLK="00" LREP="00" TYPE="INT4" ITYP="I" AGLT="00" ADEZ="00" STXT="___________"/>
    <dynprofield FNAM="%#AUTOTEXT003" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0C" LINE="01" COLN="67" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="RECORD COUNT" RES1="                                                                                                                                                                        G_SEL"/>
    <dynprofield FNAM="G_COUNT" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="30" FMB2="00" LENG="0B" LINE="01" COLN="74" LANF="00" LBLK="00" LREP="00" TYPE="INT4" ITYP="I" AGLT="00" ADEZ="00" STXT="___________"/>
    <dynprofield FNAM="G_SEL" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="02" COLN="0D" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                        G_SEL"/>
    <dynprofield FNAM="G_SEL" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FILL="C" FMB1="30" FMB2="00" LENG="15" LINE="02" COLN="0F" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" ITYP="0" AGLT="00" ADEZ="00" STXT="SHOW SELECTION SCREEN"/>
    <dynprofield FNAM="sel" DIDX="001A" FLG1="00" FLG2="00" FLG3="00" FILL="P" FMB1="30" FMB2="00" LENG="1C" LINE="02" COLN="25" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" AGLT="00" ADEZ="00" STXT="@16@_CALL_SELECTION_SCREEN__" RES1="                                                                                                                                                                        SEL_S"/>
    <dynprofield FNAM="%#AUTOTEXT002" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0A" LINE="02" COLN="69" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Record sel"/>
    <dynprofield FNAM="G_SHOW_CNT" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="00" FMB2="00" LENG="0B" LINE="02" COLN="74" LANF="00" LBLK="00" LREP="00" TYPE="INT4" ITYP="I" AGLT="00" ADEZ="00" STXT="___________"/>
    <dynprofield FNAM="CUSTOM1" DIDX="0022" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="A5" LINE="03" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="103" AGLT="11" ADEZ="52"/>
    <dynprofield FNAM="OK_CODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT..

  MODULE status_0100.
  MODULE init_screen.
  MODULE init_class_value.

PROCESS AFTER INPUT.

  MODULE exit AT EXIT-COMMAND.
  MODULE init_global_vlaue.

  FIELD g_sel
        MODULE check_g_sel ON REQUEST.
  FIELD  dd02l-tabname
        MODULE check_tabname ON REQUEST.
  FIELD  g_show_cnt
        MODULE check_tabname ON REQUEST.

  MODULE user_command_0100.</dynproflowsource>
   </dynpro>
  </dynpros>
  <pfstatus>
   <pfstatus_sta CODE="0100" MODAL="D" ACTCODE="000001" PFKCODE="000001" BUTCODE="0001" INT_NOTE="0100"/>
   <pfstatus_fun CODE="BACK" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Back"/>
   <pfstatus_fun CODE="CANC" TEXTNO="001" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
   <pfstatus_fun CODE="EXIT" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Exit"/>
   <pfstatus_fun CODE="SAVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_SAVE" ICON_ID="@2L@" FUN_TEXT="Save"/>
   <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="BACK" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="11" FUNCODE="SAVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="CANC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="EXIT" FUNNO="001"/>
   <pfstatus_set STATUS="0100" FUNCTION="BACK"/>
   <pfstatus_set STATUS="0100" FUNCTION="CANC"/>
   <pfstatus_set STATUS="0100" FUNCTION="EXIT"/>
   <pfstatus_set STATUS="0100" FUNCTION="SAVE"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="0100."/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="D" INT_NOTE="0100"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0001" MODAL="D" INT_NOTE="0100"/>
  </pfstatus>
  <source>PROGRAM  zrep000 MESSAGE-ID 0k.


*----------------------------------------------------------------------*
*       CLASS lcl_event_receiver DEFINITION.
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_receiver DEFINITION.

  PUBLIC SECTION.


    DATA: error_in_data TYPE c.
    DATA: is_key.
    DATA: initial_table TYPE c.
    METHODS:
      check_if_keyfield
         IMPORTING
            i_fieldname TYPE lvc_fname
         EXPORTING
            e_is_key TYPE char01.

    METHODS:
      check_double_entries
         IMPORTING
            pr_data_changed TYPE REF TO cl_alv_changed_data_protocol.

    METHODS:
      update_delta_tables
         IMPORTING
            pr_data_changed TYPE REF TO cl_alv_changed_data_protocol.

    METHODS:
      perform_semantic_checks
         IMPORTING
            pr_data_changed TYPE REF TO cl_alv_changed_data_protocol.


*- CLASS VARIANT
    DATA: lvc_tabname TYPE char30,          &quot;TABLE NAME
          lvc_dref_k TYPE REF TO data,      &quot;KEY FIELD DATA
          lvc_dref_o TYPE REF TO data,      &quot;ALV DATA ORIGINAL
          r_wa_dyn_table TYPE REF TO data,  &quot;?
          lvc_dref_ft TYPE REF TO data,     &quot;FIELDCATALOG FROM ALV
          lr_ins_rows TYPE REF TO data,     &quot;INSERTED ROWS
          lr_ins_tmp TYPE REF TO data,     &quot;INSERTED BAD ROWS
          lr_ins_bad      TYPE REF TO data,     &quot;INSERTED BAD ROWS
          lr_del_rows TYPE REF TO data,     &quot;DELETED ROWS
          lr_del_tmp TYPE REF TO data,     &quot;DELETED ROWS
          lr_mod_rows TYPE REF TO data.     &quot;MODIFIED ROWS
*-
    METHODS:
*----------------------------------------------------------------------*
      set_table_name
        IMPORTING i_tabname TYPE char30,
*----------------------------------------------------------------------*
      inbound_key_table
        IMPORTING i_dref TYPE REF TO data
                  i_dref_o TYPE REF TO data
                  i_dref_ft TYPE REF TO data
                  i_r_ins_rows TYPE REF TO data
                  i_r_ins_tmp TYPE REF TO data
                  i_r_del_rows TYPE REF TO data
                  i_r_del_tmp TYPE REF TO data
                  i_r_mod_rows TYPE REF TO data,

*----------------------------------------------------------------------*
      outbound_key_table
        EXPORTING e_dref TYPE REF TO data,
*----------------------------------------------------------------------*
      handle_hotspot_click
        FOR EVENT hotspot_click OF cl_gui_alv_grid
          IMPORTING e_row_id
                    e_column_id
                    es_row_no,
*----------------------------------------------------------------------*
      handle_data_changed
        FOR EVENT data_changed OF cl_gui_alv_grid
          IMPORTING er_data_changed
                    e_onf4
                    e_onf4_before
                    e_onf4_after
                    e_ucomm.


ENDCLASS.                    &quot;LCL_EVENT_RECEIVER DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_EVENT_RECEIVER IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_receiver IMPLEMENTATION.
  METHOD check_if_keyfield.

    FIELD-SYMBOLS: &lt;lvc_t_fc&gt; TYPE table,
                   &lt;f&gt; TYPE ANY.
    DATA: l_ref TYPE REF TO data.

    ASSIGN lvc_dref_ft-&gt;* TO &lt;lvc_t_fc&gt;.
    LOOP AT &lt;lvc_t_fc&gt; REFERENCE INTO l_ref.
      ASSIGN l_ref-&gt;(&apos;FIELDNAME&apos;) TO &lt;f&gt;.
      IF &lt;f&gt; EQ i_fieldname.
        e_is_key = &apos;X&apos;.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    &quot;CHECK_IF_KEYFIELD

  METHOD set_table_name.
    me-&gt;lvc_tabname = i_tabname.
  ENDMETHOD.                    &quot;SET_TABLE_NAME
*----------------------------------------------------------------------*
  METHOD outbound_key_table.
    e_dref = me-&gt;lvc_dref_k.
  ENDMETHOD.                    &quot;OUTBOUND_KEY_TABLE
*----------------------------------------------------------------------*
  METHOD inbound_key_table.
    FIELD-SYMBOLS: &lt;lvc_t_key&gt; TYPE table,
*                   &lt;lvc_s_key&gt; TYPE ANY,
                   &lt;lvc_t_o&gt; TYPE table,
*                   &lt;lvc_s_o&gt; TYPE ANY,
                   &lt;wa_dyn_table&gt; TYPE ANY,
                   &lt;lvc_t_ft&gt; TYPE ANY.
*---KEY TABLE
    me-&gt;lvc_dref_k = i_dref.
    ASSIGN lvc_dref_k-&gt;* TO &lt;lvc_t_key&gt;.
*   LOOP AT &lt;LVC_T_KEY&gt; ASSIGNING &lt;LVC_S_KEY&gt;.
*   ENDLOOP.
*---OUTPUT TABLE
    IF NOT i_dref_o IS INITIAL.
      me-&gt;lvc_dref_o = i_dref_o.
*     ASSIGN LVC_DREF_O-&gt;* TO &lt;LVC_T_O&gt;.
      ASSIGN lvc_dref_o-&gt;* TO &lt;lvc_t_o&gt;. &quot;&lt;T_DYN_TABLE&gt;.
*-----CREATE WORK AREA FOR NEW TABLE.
      CREATE DATA r_wa_dyn_table LIKE LINE OF &lt;lvc_t_o&gt;. &quot;&lt;T_DYN_TABLE&gt;.
*-----GET ACCESS TO NEW WORK AREA USING FIELD SYMBOL.
      ASSIGN r_wa_dyn_table-&gt;* TO &lt;wa_dyn_table&gt;. &quot;=&gt; &lt;ALL_TABLE1&gt;
    ENDIF.
*   LOOP AT &lt;LVC_T_O&gt; ASSIGNING &lt;LVC_S_O&gt;.
*   ENDLOOP.

*---FIELD CATALOG.
    me-&gt;lvc_dref_ft = i_dref_ft.
    ASSIGN lvc_dref_ft-&gt;* TO &lt;lvc_t_ft&gt;.

*--&gt; SETTING REF FROM ALV TO CLASS LOCAL VARIANT
    me-&gt;lr_ins_rows     = i_r_ins_rows.
    me-&gt;lr_ins_tmp      = i_r_ins_tmp.
    me-&gt;lr_del_rows     = i_r_del_rows.
    me-&gt;lr_del_tmp      = i_r_del_tmp.
    me-&gt;lr_mod_rows     = i_r_mod_rows.

  ENDMETHOD.                    &quot;SET_KEY_TABLE
*----------------------------------------------------------------------*
  METHOD handle_hotspot_click.
  ENDMETHOD.                    &quot;HANDLE_HOTSPOT_CLICK
*----------------------------------------------------------------------*
  METHOD handle_data_changed.
    PERFORM handle_data_changed USING er_data_changed
                                      lvc_dref_k
                                      lvc_dref_o
                                      lvc_dref_ft
                                      lr_ins_rows
                                      lr_ins_tmp
                                      lr_del_rows
                                      lr_del_tmp
                                      lr_mod_rows
                                      lvc_tabname.


  ENDMETHOD.                    &quot;HANDLE_DATA_CHANGED


*-----------------------------------------------------------------------
  METHOD check_double_entries.

  ENDMETHOD.                    &quot;check_double_entries
*-------------------------------------------------------
  METHOD update_delta_tables.
  ENDMETHOD.                    &quot;update_delta_tables
*-----------------------------------------------------------------------
  METHOD perform_semantic_checks.
  ENDMETHOD.                    &quot;perform_semantic_checks
ENDCLASS.                    &quot;LCL_EVENT_RECEIVER IMPLEMENTATION



DATA: gc_container TYPE REF TO cl_gui_custom_container,
      gc_grid1     TYPE REF TO cl_gui_alv_grid,
      gc_event_receiver TYPE REF TO lcl_event_receiver,
      gs_fcatlayo  TYPE lvc_s_layo,
      g_repid      TYPE sy-repid VALUE sy-repid,
      g_save,
      gs_variant   TYPE disvariant,
      gs_fieldcat       TYPE lvc_s_fcat,
      gt_fieldcat       TYPE lvc_t_fcat,
      gt_fcat_key       TYPE lvc_t_fcat,
      gt_exclude   TYPE ui_functions.

DATA: g_container(20) VALUE &apos;CUSTOM1&apos;.
*&amp;---------------------------------------------------------------------*
*&amp;  Include           Y_ALV_DYN_TAB                                    *
*&amp;---------------------------------------------------------------------*
DATA:
  r_dyn_table      TYPE REF TO data,
  r_wa_dyn_table   TYPE REF TO data.

FIELD-SYMBOLS:
  &lt;wa_dyn_table&gt;   TYPE ANY.

*-FOR ALV INTERFACE...
DATA: r_inserted_rows TYPE REF TO data,
      r_inserted_tmp TYPE REF TO data,
      r_deleted_tmp TYPE REF TO data,
      r_deleted_rows TYPE REF TO data,
      r_modified_rows TYPE REF TO data.

*-FOR ALV INTERFACE
FIELD-SYMBOLS: &lt;inserted_rows&gt; TYPE table,
               &lt;inserted_tmp&gt; TYPE table,
               &lt;deleted_rows&gt; TYPE table,
               &lt;deleted_tmp&gt; TYPE table,
               &lt;modified_rows&gt; TYPE table.


DATA: ok_code LIKE sy-ucomm.

DATA: BEGIN OF gt_toolbar OCCURS 0,
        fcode LIKE sy-ucomm,
      END OF gt_toolbar.

DATA: g_flg VALUE &apos;X&apos;.  &quot;Flag to set the change mode
&quot;X:DISPLAY MODE(DEFAULT)

DATA:
      g_ddtext  LIKE dd02t-ddtext.


FIELD-SYMBOLS:
               &lt;f&gt;  TYPE ANY,
               &lt;all_table1&gt; TYPE table,
               &lt;t_key&gt; TYPE table,
               &lt;t_ft&gt; TYPE lvc_t_fcat. &quot;FIELD CATALOG


DATA: g_count LIKE sy-index.    &quot;RECORD COUNT
DATA: g_gt_count LIKE sy-index. &quot;GRAND TOTAL
DATA: g_report_count LIKE sy-index.

**
TYPE-POOLS rsds.
DATA ds_clauses TYPE rsds_where.
DATA: g_sel VALUE &apos; &apos;,
      g_show_cnt LIKE sy-index VALUE &apos;200&apos;,
      g_selected.

DATA: g_reset_table.

TABLES: dd02l, usr02.

CLASS: cl_abap_char_utilities DEFINITION LOAD.

TYPE-POOLS: vimty, stprt, slctr, shlp.


TYPES: BEGIN OF conv_datatype_type,                   &quot;UF18315/2001b
        inttype TYPE inttype,
        datatype TYPE dynptype,
        convexit TYPE convexit,
       END OF conv_datatype_type.                     &quot;UF18315/2001e



START-OF-SELECTION.
  SELECT SINGLE * FROM usr02 WHERE bname = sy-uname.
*  CHECK usr02-class = &apos;JPMC&apos;.

  CALL SCREEN 100.

*----------------------------------------------------------------------*
*  MODULE status_0100 OUTPUT
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  PERFORM menu_display.

  CHECK NOT dd02l-tabname IS INITIAL.

  IF gc_container IS INITIAL.
    PERFORM init_alv.
  ENDIF.
ENDMODULE.                 &quot; STATUS_0100  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  INIT_CLASS_VALUE  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE init_class_value OUTPUT.

  CHECK NOT gc_event_receiver IS INITIAL.
  CHECK g_reset_table EQ &apos;X&apos;.

  DATA: l_dref   TYPE REF TO data,  &quot;TABLE KEY REF..
        l_dref_o TYPE REF TO data,  &quot;ALV OUTPUT TABLE REF..
        l_dref_ft TYPE REF TO data. &quot;FIELD CATALOG..

  PERFORM get_table_key_fields USING dd02l-tabname l_dref l_dref_o l_dref_ft.

  CALL METHOD gc_event_receiver-&gt;set_table_name( dd02l-tabname ).

  CALL METHOD gc_event_receiver-&gt;inbound_key_table
       EXPORTING i_dref   = l_dref
*                I_DREF_O = L_DREF_O
*                I_DREF_O = R_WA_DYN_TABLE
                 i_dref_o = r_dyn_table
                 i_dref_ft = l_dref_ft
                 i_r_ins_rows = r_inserted_rows
                 i_r_ins_tmp  = r_inserted_tmp
                 i_r_del_rows = r_deleted_rows
                 i_r_del_tmp  = r_deleted_tmp
                 i_r_mod_rows = r_modified_rows.

  CLEAR : g_reset_table.

ENDMODULE.                 &quot; INIT_CLASS_VALUE  OUTPUT


*----------------------------------------------------------------------*
*  MODULE exit INPUT
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
MODULE exit INPUT.
  PERFORM save_data.
  CASE ok_code.
    WHEN &apos;BACK&apos;.
      IF dd02l-tabname IS INITIAL.
        LEAVE TO SCREEN 0.
      ELSE.
        CLEAR dd02l-tabname.
        PERFORM  free_control.
        LEAVE TO SCREEN 100.
      ENDIF.
    WHEN OTHERS.
      LEAVE TO SCREEN 0.
  ENDCASE.
ENDMODULE.                 &quot; EXIT  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  INIT_GLOBAL_VLAUE  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE init_global_vlaue INPUT.
  CLEAR : g_selected.
ENDMODULE.                 &quot; INIT_GLOBAL_VLAUE  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  CHECK_G_SEL  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE check_g_sel INPUT.
  SET PARAMETER ID &apos;YMMA&apos; FIELD g_sel.
ENDMODULE.                 &quot; CHECK_G_SEL  INPUT


*&amp;---------------------------------------------------------------------*
*&amp;      Form  INIT_ALV
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM init_alv .

  CHECK gc_container IS INITIAL.

  CREATE OBJECT gc_container
    EXPORTING container_name = g_container.

  CREATE OBJECT gc_grid1
    EXPORTING i_parent = gc_container
              i_appl_events = &apos;X&apos;.

  PERFORM init_alv0.

*-메인 ALV에 잘못된 타이틀이 들어갈수 있음
  CLEAR: gs_fcatlayo-grid_title.

  CHECK gc_event_receiver IS INITIAL.
  CREATE OBJECT gc_event_receiver.
  SET HANDLER gc_event_receiver-&gt;handle_hotspot_click FOR gc_grid1.
  SET HANDLER gc_event_receiver-&gt;handle_data_changed  FOR gc_grid1.
  CALL METHOD gc_grid1-&gt;set_toolbar_interactive.

ENDFORM.                    &quot; INIT_ALV
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CHANGE_DISPLAY_ATTIRBUTE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_GS_FCATLAYO  text
*----------------------------------------------------------------------*
FORM change_display_attirbute  CHANGING p_factlayo TYPE lvc_s_layo.

  p_factlayo-cwidth_opt = &apos;X&apos;.
* P_FACTLAYO-ZEBRA      = &apos;X&apos;.
  p_factlayo-sel_mode   = &apos;D&apos;.
* P_FACTLAYO-GRID_TITLE = &apos;ALV EDIT MODE ..&apos;.
*  p_factlayo-box_fname  = &apos;CHK&apos;. &quot;&lt;--local download error
  p_factlayo-stylefname = &apos;CELLTAB&apos;.  &quot;CELL단위 HANDLIING
*  p_factlayo-ctab_fname = &apos;F_COL&apos;.    &quot;CEL color &lt;--display error
  g_save                = &apos;A&apos;.  &quot;VARIANT MODE
  gs_variant            = g_repid.

ENDFORM.                    &quot; CHANGE_DISPLAY_ATTIRBUTE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  EXCLUDE_TB_FUNCTIONS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_GT_EXCLUDE  text
*----------------------------------------------------------------------*
FORM exclude_tb_functions  CHANGING pt_exclude TYPE ui_functions.
  DATA ls_exclude TYPE ui_func.

  CLEAR : pt_exclude, pt_exclude[].

  ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_undo.
  APPEND ls_exclude TO pt_exclude.

  ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_copy_row.
  APPEND ls_exclude TO pt_exclude.

ENDFORM.                    &quot; EXCLUDE_TB_FUNCTIONS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_DISPLAY
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM alv_display .

  CHECK NOT gt_fieldcat[] IS INITIAL.

  CALL METHOD gc_grid1-&gt;set_table_for_first_display
    EXPORTING
      is_layout            = gs_fcatlayo
      it_toolbar_excluding = gt_exclude
      i_save               = g_save
      is_variant           = gs_variant
    CHANGING
*     IT_OUTTAB            = ITAB[]
      it_outtab            = &lt;all_table1&gt;
*     IT_SORT              = &apos;&apos;
      it_fieldcatalog      = gt_fieldcat[].

  CALL METHOD cl_gui_cfw=&gt;flush.

ENDFORM.                    &quot; ALV_DISPLAY
*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_0100  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0100 INPUT.
  DATA l_ucomm LIKE sy-ucomm.
  l_ucomm = ok_code.
  CLEAR : ok_code.
  CASE l_ucomm.
    WHEN &apos;TOG&apos;.
      PERFORM switch_edit_mode.
    WHEN &apos;NEW&apos;.
    WHEN &apos;COPY&apos;.
    WHEN &apos;DELE&apos;.
    WHEN &apos;UNDO&apos;.
    WHEN &apos;SBLOK&apos;.
    WHEN &apos;SEL&apos;.
      g_sel = &apos;X&apos;.
      CHECK g_selected IS INITIAL.
      PERFORM select_data_from_table.
      CLEAR : g_selected.
    WHEN &apos;SAVE&apos;.
*----DELELTE =&gt; UPDATE = &gt; INSERT 순으로 진행
      PERFORM save_data.
    WHEN &apos;SEL_S&apos;.
      g_sel = &apos;X&apos;.
      SET PARAMETER ID &apos;YMMA&apos; FIELD g_sel.
      PERFORM select_data_from_table.
    WHEN OTHERS.
  ENDCASE.

ENDMODULE.                 &quot; USER_COMMAND_0100  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SWITCH_EDIT_MODE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM switch_edit_mode .

  CHECK g_count &gt; 0 AND
        NOT gc_grid1 IS INITIAL.

  DATA: rs_stable TYPE lvc_s_stbl.
  rs_stable-row = &apos;X&apos;.
  rs_stable-col = &apos;X&apos;.

  IF gc_grid1-&gt;is_ready_for_input( ) EQ 0.  &quot;DISPALY MODE
    g_flg = space.
    CALL METHOD gc_grid1-&gt;set_ready_for_input
      EXPORTING
        i_ready_for_input = 1.             &quot;INPUT MODE

    gs_fcatlayo-zebra = &apos;&apos;.                &quot;NO ZERBRA

    CALL METHOD gc_grid1-&gt;set_frontend_layout
      EXPORTING
        is_layout = gs_fcatlayo.
  ELSE.
    g_flg = &apos;X&apos;.
    CALL METHOD gc_grid1-&gt;set_ready_for_input
      EXPORTING
        i_ready_for_input = 0.             &quot;DISPLAY MODE

    gs_fcatlayo-zebra = &apos;X&apos;.

    CALL METHOD gc_grid1-&gt;set_frontend_layout
      EXPORTING
        is_layout = gs_fcatlayo.

  ENDIF.

  CALL METHOD gc_grid1-&gt;refresh_table_display
    EXPORTING
      is_stable = rs_stable.

ENDFORM.                    &quot; SWITCH_EDIT_MODE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  MENU_DISPLAY
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM menu_display .
  SET PF-STATUS &apos;0100&apos; EXCLUDING gt_toolbar.
ENDFORM.                    &quot; MENU_DISPLAY
*&amp;---------------------------------------------------------------------*
*&amp;      Module  INIT_SCREEN  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE init_screen OUTPUT.
  GET PARAMETER ID &apos;YMMA&apos; FIELD g_sel.

  IF NOT dd02l-tabname IS INITIAL.
    SELECT SINGLE * FROM dd02l
                    WHERE tabname  EQ dd02l-tabname
                      AND as4local EQ &apos;A&apos;
                      AND tabclass EQ &apos;TRANSP&apos;.
    IF sy-subrc EQ 0.
      SELECT SINGLE ddtext INTO g_ddtext
                 FROM dd02t
                 WHERE tabname    EQ dd02l-tabname
                   AND ddlanguage EQ sy-langu
                   AND as4local   EQ dd02l-as4local
                   AND as4vers    EQ dd02l-as4vers.
    ENDIF.

  ELSE.
    CLEAR : g_ddtext.
  ENDIF.
ENDMODULE.                 &quot; INIT_SCREEN  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  CHECK_TABNAME  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE check_tabname INPUT.

  PERFORM select_data_from_table.

ENDMODULE.                 &quot; CHECK_TABNAME  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SELECT_DATA_FROM_DATABASE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM select_data_from_database .

*  SELECT COUNT(*) INTO g_gt_count
*         FROM (dd02l-tabname).

  IF ds_clauses-where_tab IS INITIAL.

    SELECT * INTO CORRESPONDING FIELDS OF
      TABLE &lt;all_table1&gt; UP TO g_show_cnt ROWS
      FROM (dd02l-tabname).
  ELSE.
    SELECT * INTO CORRESPONDING FIELDS OF
      TABLE &lt;all_table1&gt; UP TO g_show_cnt ROWS
      FROM (dd02l-tabname)
      WHERE (ds_clauses-where_tab).
  ENDIF.

  g_count = sy-dbcnt.
  MESSAGE s000 WITH g_count &apos;건의 데이터가 검색 되었습니다&apos;.

ENDFORM.                    &quot; SELECT_DATA_FROM_DATABASE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  PREPARE_FIRST_SCREEN
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM prepare_first_screen .

  CHECK NOT dd02l-tabname IS INITIAL.

  DATA: l_chk.

  FREE:  r_dyn_table,
         r_wa_dyn_table,
         r_inserted_rows,
         r_inserted_tmp,
         r_modified_rows,
         r_deleted_rows,
         r_deleted_tmp.

  PERFORM create_fldcat_itab USING dd02l-tabname
                            CHANGING l_chk.

  CHECK l_chk IS INITIAL.
  PERFORM select_data_from_database.

*-KEY 부분 수정못하게 막음..
  PERFORM cell_control.

ENDFORM.                    &quot; PREPARE_FIRST_SCREEN
*&amp;---------------------------------------------------------------------*
*&amp;      Form  FREE_CONTROL
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM free_control .

*- FREE: GC_CONTAINER,
*-       GC_GRID1.
  CHECK NOT gc_container IS INITIAL.

  FREE: gc_event_receiver.
  CLEAR : gc_event_receiver.

  CALL METHOD gc_container-&gt;free.
  CLEAR: gc_container.

  FREE: gc_container,
        gc_grid1.

ENDFORM.                    &quot; FREE_CONTROL
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CALL_SELECTION-SCREEN_N
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM call_selection_screen_n .

  GET PARAMETER ID &apos;YMMA&apos; FIELD g_sel.

  CHECK g_sel EQ &apos;X&apos;.
  CLEAR : ds_clauses.
  PERFORM selecton_screen USING ds_clauses
                                dd02l-tabname.
  g_selected = &apos;X&apos;.
ENDFORM.                    &quot; CALL_SELECTION-SCREEN_N
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SELECTON_SCREEN
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_DS_CLAUSES  text
*      --&gt;P_DD02L-TABNAME  text
*      --&gt;P_ENDFORM  text
*----------------------------------------------------------------------*
FORM selecton_screen  USING   ds_clauses TYPE rsds_where
                              tabname.

  DATA texpr TYPE rsds_texpr.
  DATA twhere TYPE rsds_twhere.
  DATA trange TYPE rsds_trange.

*  DATA BEGIN OF qcat.                    &quot;Selections View for
*          INCLUDE STRUCTURE rsdsqcat.    &quot;Free Selectoptions
*  DATA END OF qcat.
*
  DATA BEGIN OF tabs OCCURS 10.
          INCLUDE STRUCTURE rsdstabs.
  DATA END   OF tabs.

  DATA BEGIN OF fields OCCURS 10.
          INCLUDE STRUCTURE rsdsfields.
  DATA END   OF fields.

  DATA BEGIN OF efields OCCURS 10.
          INCLUDE STRUCTURE rsdsfields.
  DATA END   OF efields.

  DATA selid LIKE rsdynsel-selid.
  DATA actnum LIKE sy-tfill.
  DATA title LIKE sy-title VALUE &apos;Selection Screen&apos;.

  DATA: maxnum LIKE sy-subrc VALUE &apos;69&apos;.

  CLEAR    tabs.
  tabs-prim_tab = tabname.
  COLLECT  tabs.

  DATA: position LIKE dd03l-position.
  DATA: keyflag  LIKE dd03l-keyflag.

  CLEAR fields.

  fields-tablename = tabname.
  fields-sign      = &apos;I&apos;.

  DATA: step LIKE sy-subrc.

  SELECT fieldname keyflag position
    INTO (fields-fieldname, keyflag, position)
    FROM dd03l
    WHERE tabname = tabname
      AND fieldname NOT LIKE &apos;.INCLU%&apos;
      AND datatype NE &apos;CLNT&apos;
    ORDER BY position.
    ADD 1 TO step.
    CHECK step LE maxnum.
    IF keyflag &lt;&gt; &apos;X&apos;.
      efields = fields.
      APPEND efields.
    ENDIF.
    APPEND fields.
  ENDSELECT.

  IF sy-subrc &lt;&gt; 0.
    RAISE table_not_valid.
  ENDIF.

  CALL FUNCTION &apos;FREE_SELECTIONS_INIT&apos;
    EXPORTING
      expressions              = texpr
      kind                     = &apos;F&apos;
    IMPORTING
      selection_id             = selid
      expressions              = texpr
      where_clauses            = twhere
      field_ranges             = trange
      number_of_active_fields  = actnum
    TABLES
      tables_tab               = tabs
      fields_tab               = fields
      fields_not_selected      = efields
    EXCEPTIONS
      fields_incomplete        = 01
      fields_no_join           = 02
      field_not_found          = 03
      no_tables                = 04
      table_not_found          = 05
      expression_not_supported = 06
      incorrect_expression     = 07
      illegal_kind             = 08
      area_not_found           = 09
      inconsistent_area        = 10
      kind_f_no_fields_left    = 11
      kind_f_no_fields         = 12
      too_many_fields          = 13.

  IF sy-subrc = 0.
    CALL FUNCTION &apos;FREE_SELECTIONS_DIALOG&apos;
      EXPORTING
        selection_id            = selid
        title                   = title
      IMPORTING
        where_clauses           = twhere
        expressions             = texpr
        field_ranges            = trange
        number_of_active_fields = actnum
      TABLES
        fields_tab              = fields
      EXCEPTIONS
        internal_error          = 01
        no_action               = 02
*        no_fields_selected      = 03
*        no_tables_selected      = 04
        selid_not_found         = 05.

    IF sy-subrc = 0.
      CLEAR ds_clauses.
      MOVE tabname TO ds_clauses-tablename.
      READ TABLE twhere WITH KEY ds_clauses-tablename INTO ds_clauses.
      CLEAR : ok_code.
      IF sy-subrc &lt;&gt; 0.
*-       RAISE other_error.
      ENDIF.
    ELSE.
*-     RAISE other_error.
    ENDIF.
  ELSE.
*-   RAISE other_error.
  ENDIF.

ENDFORM.                    &quot; SELECTON_SCREEN
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SELECT_DATA_FROM_TABLE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM select_data_from_table .
  CHECK NOT dd02l-tabname IS INITIAL.
  SELECT SINGLE * FROM dd02l
                  WHERE tabname  EQ dd02l-tabname
                    AND as4local EQ &apos;A&apos;
                    AND tabclass EQ &apos;TRANSP&apos;.
  IF sy-subrc NE 0.
    MESSAGE e000 WITH &apos;SAP에 존재하지 않는 테이블 입니다!&apos;.
    RETURN.
  ENDIF.

  CONDENSE dd02l-tabname.
  IF NOT ( dd02l-tabname+0(1) EQ &apos;Z&apos; OR
           dd02l-tabname+0(1) EQ &apos;Y&apos; ).
    MESSAGE i000 WITH &apos;SAP 표준 테이블입니다!&apos;.
    EXIT.
  ENDIF.

  PERFORM save_data.

  g_reset_table = &apos;X&apos;.
  PERFORM free_control.
  PERFORM call_selection_screen_n.
  PERFORM prepare_first_screen.

ENDFORM.                    &quot; SELECT_DATA_FROM_TABLE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_TABLE_KEY_FIELDS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LVC_TABNAME  text
*----------------------------------------------------------------------*
FORM get_table_key_fields  USING l_tabname
                                 l_dref TYPE REF TO data
                                 l_dref_o TYPE REF TO data
                                 ft_dref TYPE REF TO data.

  DATA: ls_dref TYPE REF TO data.

  DATA: lt_fieldcat TYPE lvc_t_fcat,
        lt_fcat_key TYPE lvc_t_fcat,
        ls_fieldcat TYPE lvc_s_fcat,
        lv_tabname LIKE dd02l-tabname.
  CLEAR : lt_fieldcat.

  lv_tabname =  l_tabname.

  CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
    EXPORTING
      i_structure_name = lv_tabname
    CHANGING
      ct_fieldcat      = lt_fieldcat[].

  CLEAR : ls_fieldcat.
  ls_fieldcat-outputlen = 1.
  ls_fieldcat-inttype  =&apos;C&apos;.
  ls_fieldcat-intlen   = 1.
  ls_fieldcat-fieldname = &apos;CHK&apos;.
  APPEND ls_fieldcat TO lt_fieldcat.

**  CALL METHOD CL_ALV_TABLE_CREATE=&gt;CREATE_DYNAMIC_TABLE
**    EXPORTING
**      IT_FIELDCATALOG = LT_FIELDCAT
**    IMPORTING
**      EP_TABLE        = L_DREF_O.

  PERFORM make_table USING lt_fieldcat
                           l_dref_o.


  LOOP AT lt_fieldcat INTO ls_fieldcat.
    IF ls_fieldcat-key NE &apos;X&apos;.
      DELETE lt_fieldcat.
    ENDIF.
  ENDLOOP.

  gt_fcat_key[] = lt_fieldcat[].

*  CALL METHOD CL_ALV_TABLE_CREATE=&gt;CREATE_DYNAMIC_TABLE
*    EXPORTING
*      IT_FIELDCATALOG = LT_FIELDCAT
*    IMPORTING
*      EP_TABLE        = L_DREF.
  PERFORM make_table USING lt_fieldcat
                           l_dref.

  FIELD-SYMBOLS: &lt;fs&gt; TYPE ANY,
                 &lt;f&gt;  TYPE ANY,
                 &lt;fd&gt; TYPE ANY,
                 &lt;fld&gt; TYPE ANY,
                 &lt;s_ft&gt; TYPE lvc_s_fcat.
*                 &lt;ls_wa_to&gt; TYPE ANY.
*----------------------------------------------------------------------*
*-FIELD CATALOG FIELD들을 CLASS 내부에서 사용하기 위해 DREF를 만들듬
  CREATE DATA ft_dref TYPE STANDARD TABLE OF lvc_s_fcat.
  ASSIGN ft_dref-&gt;* TO &lt;t_ft&gt;.
  LOOP AT lt_fieldcat ASSIGNING &lt;s_ft&gt;.
    APPEND &lt;s_ft&gt; TO &lt;t_ft&gt;.
  ENDLOOP.
*----------------------------------------------------------------------*
*-
  CREATE DATA ls_dref TYPE (l_tabname).
  ASSIGN ls_dref-&gt;* TO &lt;fs&gt;.

  ASSIGN l_dref-&gt;* TO &lt;t_key&gt;.

*- CREATE DATA L_DREF_O LIKE LINE OF &lt;ALL_TABLE1&gt;.
**  ASSIGN L_DREF_O-&gt;* TO &lt;T_O&gt;.
**  &lt;T_O&gt;[] = &lt;ALL_TABLE1&gt;[].

  CLEAR : lt_fcat_key.
  LOOP AT &lt;all_table1&gt; ASSIGNING &lt;f&gt;.
    LOOP AT lt_fieldcat INTO ls_fieldcat.
      ASSIGN COMPONENT ls_fieldcat-fieldname OF STRUCTURE &lt;f&gt; TO &lt;fld&gt;.
      ASSIGN ls_dref-&gt;(ls_fieldcat-fieldname) TO &lt;fd&gt;.
      &lt;fd&gt; = &lt;fld&gt;.
    ENDLOOP.
*---태이블 STRUCTURE중에서 키부분만 KEY TABLE에 APPEND 된다.
    APPEND &lt;fs&gt; TO &lt;t_key&gt;.
  ENDLOOP.



ENDFORM.                    &quot; GET_TABLE_KEY_FIELDS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_DATA_CHANGED
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_ER_DATA_CHANGED  text
*----------------------------------------------------------------------*
FORM handle_data_changed  USING er_data_changed
                           TYPE REF TO cl_alv_changed_data_protocol
                           lvc_dref_k TYPE REF TO data
                           lvc_dref_o TYPE REF TO data
                           lvc_dref_ft TYPE REF TO data
                           lr_ins_rows TYPE REF TO data
                           lr_ins_tmp TYPE REF TO data
                           lr_del_rows TYPE REF TO data
                           lr_del_tmp TYPE REF TO data
                           lr_mod_rows TYPE REF TO data
                           lv_tabname.

  DATA: lt_good_cells TYPE lvc_t_modi.
*        ls_good_cells TYPE lvc_t_modi.
*
*  DATA: l_ref TYPE REF TO data.
  FIELD-SYMBOLS: &lt;lvc_t_key&gt; TYPE table,
*                 &lt;lvc_t_key_f&gt; TYPE table,
*                 &lt;lvc_s_key_f&gt; TYPE table,
                 &lt;lvc_t_ft&gt; TYPE table,
*                 &lt;lvc_s_ft&gt; TYPE ANY,
*                 &lt;lvc_s_key&gt; TYPE ANY,
                 &lt;all_tab&gt; TYPE table,
*                 &lt;lvc_s_o&gt; TYPE ANY,
*                 &lt;wa_to&gt; TYPE ANY,
                 &lt;f&gt; TYPE ANY,
                 &lt;f2&gt; TYPE ANY,
                 &lt;f3&gt; TYPE ANY,
                 &lt;lvc_t_modi&gt; TYPE table.

  SORT er_data_changed-&gt;mt_mod_cells BY row_id.
  SORT er_data_changed-&gt;mt_good_cells BY row_id.

  lt_good_cells[] = er_data_changed-&gt;mt_good_cells[].

  ASSIGN er_data_changed-&gt;mp_mod_rows-&gt;* TO &lt;lvc_t_modi&gt;.


*---KEY TABLE
  ASSIGN lvc_dref_k-&gt;* TO &lt;lvc_t_key&gt;.
* LOOP AT &lt;LVC_T_KEY&gt; ASSIGNING &lt;LVC_S_KEY&gt;.
* ENDLOOP.

*---OUTPUT TABLE
  ASSIGN lvc_dref_o-&gt;* TO &lt;all_tab&gt;.
* LOOP AT &lt;ALL_TAB&gt; ASSIGNING &lt;LVC_S_O&gt;.
* ENDLOOP.

*-FIELD CATALOG TABLE (KEY FIELD ONLY)
  ASSIGN lvc_dref_ft-&gt;* TO &lt;lvc_t_ft&gt;.

  DATA: l_mod_cells TYPE lvc_s_modi,
        l_mod_cel   TYPE lvc_s_modi,
        l_good_cells TYPE lvc_s_modi,
*        l_good_cel   TYPE lvc_s_modi,
*        l_row_id    TYPE lvc_s_row,
*        l_col_id    TYPE lvc_s_col,
        l_fcat      TYPE lvc_s_fcat.

*----------------------------------------------------------------------*
* CHECK INSERTED ROWS
*----------------------------------------------------------------------*
*-CHECK INSERTED ROWS.
  DATA: lp_wa TYPE REF TO data,
*        l_wa  TYPE REF TO data,
        r_wa  TYPE REF TO data,
        lp_wa2 TYPE REF TO data,
        lp_wa3 TYPE REF TO data.

  DATA: l_ins_rows TYPE lvc_s_moce,
        l_chk,
        l_inserted,
*        l_tabname(20),
        l_end_of.
*        l_key_error.
  FIELD-SYMBOLS: &lt;ls_wa&gt; TYPE ANY,
                 &lt;ls_wa2&gt; TYPE ANY,
                 &lt;ls_wa3&gt; TYPE ANY,
                 &lt;l_wa&gt; TYPE ANY,
                 &lt;wa&gt; TYPE ANY,
                 &lt;wwa&gt; TYPE ANY,
                 &lt;wa1&gt; TYPE ANY,
                 &lt;wa2&gt; TYPE ANY.
*                 &lt;wa3&gt; TYPE ANY,
*                 &lt;wa4&gt; TYPE ANY,
*                 &lt;wa5&gt; TYPE ANY,
*                 &lt;inner_tab&gt; TYPE table,
*                 &lt;inserted_rows&gt; TYPE table,
*                 &lt;inserted_bad_rows&gt; TYPE table,
*                 &lt;ins_bad&gt; TYPE table,
*                 &lt;deleted_rows&gt; TYPE table,
*                 &lt;modified_rows&gt; TYPE table.

*  DATA: r_ref     TYPE REF TO data.
  FIELD-SYMBOLS: &lt;cell&gt; TYPE lvc_t_styl.

  ASSIGN lr_ins_rows-&gt;* TO &lt;inserted_rows&gt;.
  ASSIGN lr_del_rows-&gt;* TO &lt;deleted_rows&gt;.
  ASSIGN lr_mod_rows-&gt;* TO &lt;modified_rows&gt;.
  ASSIGN er_data_changed-&gt;mp_mod_rows-&gt;* TO &lt;lvc_t_modi&gt;.
*-MODI 된 전체 ROWS : &lt;LVC_T_MODI&gt;

  CREATE DATA lp_wa LIKE LINE OF &lt;lvc_t_modi&gt;.
  ASSIGN lp_wa-&gt;* TO &lt;ls_wa&gt;.

*----------------------------------------------------------------------*
  DATA: r1_table TYPE REF TO data,
        r11_table TYPE REF TO data,
        r21_table TYPE REF TO data.

  r11_table = lr_ins_tmp.  &quot;중복체크를 위해 INSERT된 데이터
  r21_table = lr_del_tmp.  &quot;중복체크를 위해 DELETE된 데이터
*------DB SELECT를 위해 TEMP ITAB
  CREATE DATA r1_table TYPE STANDARD TABLE OF (lv_tabname).

*----------------------------------------------------------------------*
*- CHECK DELETED ROWS
*----------------------------------------------------------------------*
* : INSERTED_ROWS에 데이터가 존재하는 경우는 INSERTED_ROWS 에서만
*   ROW를 DELETE 해주고 DELETEED_ROWS 에 APPEND 하지 않아도 된다
*   INSERTED_ROW에 데이터가 없는 경우는 기존의 DB에서 가져온
*   DATA이므로 삭제하게 되면 DB에서 삭제하여야 하므로
*   MODIFIED_ROWS에 데이터가 존재하는지 확인하여
*   있으면 삭제하여주고
*   DELETED_ROWS에 APPEND 한다
*----------------------------------------------------------------------*
  DATA: r_table TYPE REF TO data.
  DATA: lt_where LIKE STANDARD TABLE OF rsdswhere WITH HEADER LINE.
  FIELD-SYMBOLS: &lt;table&gt; TYPE table.

*  CALL METHOD CL_ALV_TABLE_CREATE=&gt;CREATE_DYNAMIC_TABLE
*    EXPORTING
*      IT_FIELDCATALOG = ER_DATA_CHANGED-&gt;MT_FIELDCATALOG
*    IMPORTING
*      EP_TABLE        = R_TABLE.

  PERFORM make_table USING er_data_changed-&gt;mt_fieldcatalog
                           r_table.

  ASSIGN r_table-&gt;* TO &lt;table&gt;.

  DATA: l_del_row TYPE lvc_s_moce.
  LOOP AT er_data_changed-&gt;mt_deleted_rows INTO l_del_row.
*---ALV에서 삭제된 ROW의 DATA를 읽어 온다.
    READ TABLE &lt;all_tab&gt; INDEX l_del_row-row_id REFERENCE INTO r_wa.

    ASSIGN r_wa-&gt;* TO &lt;wa&gt;.
    ASSIGN r_wa-&gt;(&apos;CELLTAB&apos;) TO &lt;cell&gt;.
    CLEAR : &lt;cell&gt;[].
    ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wwa&gt;.
    CREATE DATA lp_wa3 LIKE LINE OF &lt;deleted_rows&gt;.
    ASSIGN lp_wa3-&gt;* TO &lt;ls_wa3&gt;.

*---------KEY DATA를 만듬
    LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
      IF l_fcat-key NE &apos;X&apos;.
        IF l_fcat-tabname EQ space. &quot;CELLTAB COLTAB
*-              ASSIGN R_WA-&gt;(&apos;CELLTAB&apos;) TO &lt;CELL&gt;.
*-              CLEAR: &lt;CELL&gt;[].
        ELSE.
          ASSIGN COMPONENT l_fcat-fieldname
                           OF STRUCTURE &lt;wwa&gt; TO &lt;f&gt;.
*---------------KEY 이외의 DATA는 CLEAR 해줌
          &lt;f&gt; = &apos;&apos;.
        ENDIF.
      ELSE.           &quot;KEY DATA
        ASSIGN COMPONENT l_fcat-fieldname
                         OF STRUCTURE &lt;wwa&gt; TO &lt;f&gt;.
        ASSIGN COMPONENT l_fcat-fieldname
                         OF STRUCTURE &lt;ls_wa3&gt; TO &lt;f3&gt;.
        &lt;f3&gt; = &lt;f&gt;.
      ENDIF.
    ENDLOOP.

    CLEAR : l_chk.
    LOOP AT &lt;inserted_rows&gt; ASSIGNING &lt;wa&gt;.
      ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wa1&gt;.
*-----------KEY DATA를 만듬
      LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
        IF l_fcat-key NE &apos;X&apos; AND
           l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
          ASSIGN COMPONENT l_fcat-fieldname
                           OF STRUCTURE &lt;wa1&gt; TO &lt;f&gt;.
*----------------KEY 이외의 DATA는 CLEAR 해줌
          &lt;f&gt; = &apos;&apos;.
        ENDIF.
      ENDLOOP.
      IF &lt;wwa&gt; EQ &lt;wa1&gt;.
        l_chk = &apos;X&apos;.  &quot;&lt;INSERTED_ROWS&gt;에 데이터 삭제
        DELETE &lt;inserted_rows&gt;.
      ENDIF.
    ENDLOOP.

*----------------------------------------------------------------------*
    IF l_chk EQ space.
*----------------------------------------------------------------------*
      CREATE DATA lp_wa2 LIKE LINE OF &lt;deleted_rows&gt;.
      ASSIGN lp_wa2-&gt;* TO &lt;ls_wa2&gt;.

      LOOP AT &lt;modified_rows&gt; ASSIGNING &lt;wa&gt;.
        ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wa1&gt;.
*-----------KEY DATA를 만듬
        LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
          IF l_fcat-key NE &apos;X&apos; AND
             l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
            ASSIGN COMPONENT l_fcat-fieldname
                             OF STRUCTURE &lt;wa1&gt; TO &lt;f&gt;.
*----------------KEY 이외의 DATA는 CLEAR 해줌
            &lt;f&gt; = &apos;&apos;.
          ELSE.  &quot;KEY DATA
            IF l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
              ASSIGN COMPONENT l_fcat-fieldname
                                OF STRUCTURE &lt;wa1&gt; TO &lt;f&gt;.
              ASSIGN COMPONENT l_fcat-fieldname
                               OF STRUCTURE &lt;ls_wa2&gt; TO &lt;f2&gt;.
              &lt;f2&gt; = &lt;f&gt;.
            ENDIF.
          ENDIF.
        ENDLOOP.
*-----&lt;WWA&gt; : &lt;ALL_TAB&gt;에서 KEY 부분 DATA
*-----&lt;WA1&gt; : &lt;MODIFED_ROWS&gt; KEY 부분 DATA
        CLEAR : l_chk.
        IF &lt;wwa&gt; EQ &lt;wa1&gt;.
*-        L_CHK = &apos;X&apos;.  &quot;&lt;MODIFIED_ROWS&gt;에 데이터 삭제
          &quot;DB DATA 가 삭제되었음..
          DELETE &lt;modified_rows&gt;.
*-        APPEND &lt;LS_WA2&gt; TO &lt;DELETED_ROWS&gt;.
        ENDIF.
      ENDLOOP.

*----------------------------------------------------------------------*
*---DB TABLE에서 가져온 DATA가 삭제 되었는지를 체크 ...?
*----------------------------------------------------------------------*
      DATA: l_tabix TYPE i.  CLEAR : l_tabix.
      FIELD-SYMBOLS: &lt;k_f&gt; TYPE ANY.
*-----&lt;LS_WA3&gt; : &lt;ALL_TAB&gt; 에서 KEY DATA
      IF NOT &lt;ls_wa3&gt; IS INITIAL.
        CLEAR : lt_where[].

        LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                                 WHERE key EQ &apos;X&apos; AND
                                       fieldname NE &apos;MANDT&apos;.
          ASSIGN COMPONENT l_fcat-fieldname
                              OF STRUCTURE &lt;ls_wa3&gt; TO &lt;k_f&gt;.
          ADD 1 TO l_tabix.
          CLEAR : lt_where.
          IF l_tabix &gt; 1.
            APPEND &apos;AND&apos; TO lt_where.
          ENDIF.
          CONCATENATE l_fcat-fieldname &apos; EQ &apos;&apos;&apos; &lt;k_f&gt; &apos;&apos;&apos;&apos;
                      INTO lt_where.
          APPEND lt_where.

        ENDLOOP.

        SELECT * INTO CORRESPONDING FIELDS OF
          TABLE &lt;table&gt;
          FROM (lv_tabname)
          WHERE (lt_where).
        IF sy-subrc EQ 0.
*---------DB에서 가져온 데이터 이므로 삭제대상 !
          APPEND &lt;ls_wa3&gt; TO &lt;deleted_rows&gt;.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.
*----------------------------------------------------------------------*
**
  DATA: l_error,
        l_dup_chk.
  CLEAR : l_error.
  CLEAR : l_chk.
  LOOP AT er_data_changed-&gt;mt_mod_cells INTO l_mod_cells.
    READ TABLE er_data_changed-&gt;mt_inserted_rows INTO l_ins_rows
                                  WITH KEY row_id = l_mod_cells-row_id.
    IF sy-subrc EQ 0.  &quot;신규 ROW DATA
      READ TABLE er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                              WITH KEY fieldname = l_mod_cells-fieldname.
      IF l_mod_cells-error EQ &apos;X&apos; AND
         l_fcat-key        EQ &apos;X&apos;.
        l_chk = &apos;X&apos;. &quot;KEY DATA에 ERROR가 있는지 체크함
      ELSEIF l_fcat-key        EQ &apos;X&apos;.
        ASSIGN COMPONENT l_mod_cells-fieldname
                                           OF STRUCTURE &lt;ls_wa&gt; TO &lt;f&gt;.
        &lt;f&gt; = l_mod_cells-value.
      ENDIF.

      CLEAR : l_end_of.
      AT END OF row_id.
        l_end_of = &apos;X&apos;.
      ENDAT.
      IF l_end_of EQ &apos;X&apos;.

        IF NOT &lt;ls_wa&gt; IS INITIAL. &quot;빈ROW는 APPEND하지않는다...
          IF l_chk EQ &apos;X&apos;.  &quot;KEY DATA에 에러가 있음
          ELSE.             &quot;KEY DATA에 에러가 없음
*-            APPEND &lt;LS_WA&gt; TO &lt;INSERTED_ROWS&gt;.
*-            나중에 비교할때 문제가 있어서 반드시 &lt;LVC_T_MODI&gt;를
*-            APPEND 해야함
*----------------------------------------------------------------------*
*-----------(DUPLICATED CHECK-중복체크) 필요함
            PERFORM double_entry_check USING er_data_changed
                                             lr_ins_rows
                                             lr_del_rows
                                             lr_mod_rows
                                             l_mod_cells-tabix
                                             l_mod_cells-row_id
                                             lv_tabname
                                             &apos;X&apos;
                                             lvc_dref_o  &quot; &lt;ALL_TAB&gt;
                                             r1_table
                                             r11_table
                                             r21_table
                                       CHANGING l_dup_chk.
            CHECK l_dup_chk IS INITIAL.
*----------------------------------------------------------------------*
            READ TABLE &lt;lvc_t_modi&gt; ASSIGNING &lt;wa&gt;
                                     INDEX l_mod_cells-tabix.

            APPEND &lt;wa&gt; TO &lt;inserted_rows&gt;.
            LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                              WHERE key  = &apos;X&apos;.
              CALL METHOD er_data_changed-&gt;modify_style
                EXPORTING
                  i_fieldname = l_fcat-fieldname
                  i_row_id    = l_mod_cells-row_id
                  i_style     = cl_gui_alv_grid=&gt;mc_style_disabled.
            ENDLOOP.

          ENDIF.
        ENDIF.
        CLEAR : l_chk. &quot;=&gt; AT NEW ROW_ID 에서 해줘도 될것임..
      ENDIF.
    ELSE.              &quot;기존의 ROW가 MODIFY 됨
*-----*
*-----KEY 부분이 ERROR가 있는 상태에서 다른부분만 수정하였을경우를
*-----체크함
      AT NEW row_id.
        CLEAR : l_error.
      ENDAT.
      READ TABLE er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                              WITH KEY fieldname = l_mod_cells-fieldname.
      IF l_mod_cells-error EQ &apos;X&apos; AND
         l_fcat-key        EQ &apos;X&apos;.
        l_error = &apos;X&apos;. &quot;KEY DATA에 ERROR가 있는지 체크함
      ENDIF.

*-----*
      CREATE DATA lp_wa TYPE lvc_s_modi.
      ASSIGN lp_wa-&gt;* TO &lt;l_wa&gt;.
      CLEAR : l_chk.

      CLEAR : l_end_of.
      AT END OF row_id.
        l_end_of = &apos;X&apos;.
      ENDAT.
      IF l_end_of EQ &apos;X&apos;.
        CHECK l_error NE &apos;X&apos;. &quot;KEY 부분 DATA에 ERROR가 없어야 한다.

        LOOP AT lt_good_cells INTO l_good_cells.
          CHECK l_mod_cells-row_id EQ l_good_cells-row_id.

          CLEAR : l_end_of.
          AT END OF row_id.
            l_end_of = &apos;X&apos;.
          ENDAT.

          CHECK l_end_of EQ &apos;X&apos;.

          CLEAR: l_chk.
          READ TABLE &lt;lvc_t_modi&gt; REFERENCE INTO r_wa
                                 INDEX l_good_cells-tabix.
          ASSIGN r_wa-&gt;* TO &lt;wa&gt;.
          ASSIGN r_wa-&gt;(&apos;CELLTAB&apos;) TO &lt;cell&gt;.
          CLEAR : &lt;cell&gt;[].
          ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wwa&gt;.
*---------KEY DATA를 만듬
          LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
            IF l_fcat-key NE &apos;X&apos;.
              IF l_fcat-tabname EQ space. &quot;CELLTAB COLTAB
*-              ASSIGN R_WA-&gt;(&apos;CELLTAB&apos;) TO &lt;CELL&gt;.
*-              CLEAR: &lt;CELL&gt;[].
              ELSE.
                ASSIGN COMPONENT l_fcat-fieldname
                                 OF STRUCTURE &lt;wwa&gt; TO &lt;f&gt;.
*---------------KEY 이외의 DATA는 CLEAR 해줌
                &lt;f&gt; = &apos;&apos;.
              ENDIF.
            ENDIF.
          ENDLOOP.
          LOOP AT &lt;inserted_rows&gt; ASSIGNING &lt;wa&gt;.
            ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wa1&gt;.
*-----------KEY DATA를 만듬
            LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
              IF l_fcat-key NE &apos;X&apos; AND
                 l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
                ASSIGN COMPONENT l_fcat-fieldname
                                 OF STRUCTURE &lt;wa1&gt; TO &lt;f&gt;.
*----------------KEY 이외의 DATA는 CLEAR 해줌
                &lt;f&gt; = &apos;&apos;.
              ENDIF.
            ENDLOOP.
            IF &lt;wwa&gt; EQ &lt;wa1&gt;.
              l_chk = &apos;X&apos;.  &quot;&lt;INSERTED_ROWS&gt;에 데이터존재
              READ TABLE &lt;lvc_t_modi&gt; ASSIGNING &lt;wa2&gt;
                                 INDEX l_good_cells-tabix.
              MODIFY &lt;inserted_rows&gt; FROM &lt;wa2&gt;.
            ENDIF.
          ENDLOOP.


          IF l_chk NE &apos;X&apos;. &quot;&lt;INSERTED_ROWS&gt; 에 DATA 없음
*----------------------------------------------------------------------*
            DATA: l_is_key, l_has_error.
            DATA: l_mode TYPE raw4.
            CLEAR : l_chk, &lt;ls_wa&gt;, l_is_key, l_has_error.

            LOOP AT er_data_changed-&gt;mt_mod_cells INTO l_mod_cel
                            WHERE row_id EQ l_good_cells-row_id.
              READ TABLE er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                            WITH KEY fieldname = l_mod_cel-fieldname
                                     key       = &apos;X&apos;.
              IF sy-subrc EQ 0.
                l_is_key = &apos;X&apos;.
                IF l_mod_cel-error EQ &apos;X&apos;.
                  l_has_error = &apos;X&apos;.
                ENDIF.
              ENDIF.
            ENDLOOP.
            CLEAR : l_inserted.
            IF l_is_key EQ &apos;X&apos; AND    &quot;KEY DATA가 있음
               l_has_error EQ  space. &quot;ERROR가 없음
*----------------------------------------------------------------------*
*-------------(DUPLICATED CHECK-중복체크) 필요함
              PERFORM double_entry_check USING er_data_changed
                                              lr_ins_rows
                                              lr_del_rows
                                              lr_mod_rows
                                              l_mod_cells-tabix
                                              l_mod_cells-row_id
                                              lv_tabname
                                              &apos;X&apos;
                                              lvc_dref_o
                                              r1_table
                                              r11_table
                                              r21_table
                                        CHANGING l_dup_chk.
              IF l_dup_chk IS INITIAL.
*----------------------------------------------------------------------*
                READ TABLE &lt;lvc_t_modi&gt; ASSIGNING &lt;wa&gt;
                                INDEX l_good_cells-tabix.
                APPEND &lt;wa&gt; TO &lt;inserted_rows&gt;.
                l_inserted = &apos;X&apos;.
                LOOP AT er_data_changed-&gt;mt_fieldcatalog
                                  INTO l_fcat WHERE key  = &apos;X&apos;.
                  l_mode = cl_gui_alv_grid=&gt;mc_style_disabled.
                  CALL METHOD er_data_changed-&gt;modify_style
                    EXPORTING
                      i_fieldname = l_fcat-fieldname
                      i_row_id    = l_mod_cells-row_id
                      i_style     = l_mode.
                ENDLOOP.
              ENDIF.
            ENDIF.

*----------------------------------------------------------------------*
            IF l_inserted EQ space. &quot; &lt;INSERTED_ROWS&gt;에 APPPEND 안함
              CLEAR: l_chk.
              READ TABLE &lt;lvc_t_modi&gt; REFERENCE INTO r_wa
                                     INDEX l_good_cells-tabix.
              ASSIGN r_wa-&gt;* TO &lt;wa&gt;.
              ASSIGN r_wa-&gt;(&apos;CELLTAB&apos;) TO &lt;cell&gt;.
              CLEAR: &lt;cell&gt;[].
              ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wwa&gt;.
*-------------KEY DATA를 만듬
              LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
                IF l_fcat-key NE &apos;X&apos;.
                  IF l_fcat-tabname EQ space. &quot;CELLTAB COLTAB
*-                  ASSIGN R_WA-&gt;(&apos;CELLTAB&apos;) TO &lt;CELL&gt;.
*-                  CLEAR: &lt;CELL&gt;[].
                  ELSE.
                    ASSIGN COMPONENT l_fcat-fieldname
                                     OF STRUCTURE &lt;wwa&gt; TO &lt;f&gt;.
*--------------------KEY 이외의 DATA는 CLEAR 해줌
                    &lt;f&gt; = &apos;&apos;.
                  ENDIF.
                ENDIF.
              ENDLOOP.

              LOOP AT &lt;modified_rows&gt; ASSIGNING &lt;wa&gt;.
                ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wa1&gt;.
*---------------KEY DATA를 만듬
                LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
                  IF l_fcat-key NE &apos;X&apos; AND
                     l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
                    ASSIGN COMPONENT l_fcat-fieldname
                                     OF STRUCTURE &lt;wa1&gt; TO &lt;f&gt;.
*-------------------KEY 이외의 DATA는 CLEAR 해줌
                    &lt;f&gt; = &apos;&apos;.
                  ENDIF.
                ENDLOOP.
                IF &lt;wwa&gt; EQ &lt;wa1&gt;.
                  l_chk = &apos;X&apos;.  &quot;&lt;MODIFIED_ROWS&gt;에 데이터존재
                  READ TABLE &lt;lvc_t_modi&gt; ASSIGNING &lt;wa2&gt;
                                     INDEX l_good_cells-tabix.
                  MODIFY &lt;modified_rows&gt; FROM &lt;wa2&gt;.
                ENDIF.
              ENDLOOP.
              IF l_chk NE &apos;X&apos;.  &quot;&lt;MODIFIED_ROWS&gt;에 데이터 없다
                READ TABLE &lt;lvc_t_modi&gt; ASSIGNING &lt;wa2&gt;
                                   INDEX l_good_cells-tabix.
                APPEND &lt;wa2&gt; TO &lt;modified_rows&gt;.

              ENDIF.
            ENDIF.
          ENDIF.

        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDLOOP.

ENDFORM.                    &quot; HANDLE_DATA_CHANGED
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CREATE_FLDCAT_ITAB
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_DD02L-TABNAME  text
*      &lt;--P_L_CHK  text
*----------------------------------------------------------------------*
FORM create_fldcat_itab  USING tab_name
                         CHANGING l_chk.

*  CLEAR : GT_FIELD, GT_FCAT,
*          GT_FIELD[], GT_FCAT[].
*  CLEAR : GT_FIELDCAT, GT_FIELDCAT[].

  DATA:  ls_fieldcat       TYPE lvc_s_fcat,
         lt_fieldcat       TYPE lvc_t_fcat.

  CLEAR : lt_fieldcat[].


  CHECK NOT dd02l-tabname IS INITIAL.

* TARGET TABLE에 모든 필드를 가져온다.
  CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
    EXPORTING
      i_structure_name = dd02l-tabname
    CHANGING
      ct_fieldcat      = lt_fieldcat[].


  CLEAR : ls_fieldcat.

  ls_fieldcat-fieldname = &apos;CELLTAB&apos;.
  ls_fieldcat-ref_field = &apos;CELL_STYLE&apos;.
  ls_fieldcat-ref_table = &apos;ISSUE_ALV&apos;.
  ls_fieldcat-tech      = &apos;X&apos;.
  APPEND ls_fieldcat TO lt_fieldcat.

  ls_fieldcat-fieldname = &apos;T_CELLCOLORS&apos;.
  ls_fieldcat-ref_field = &apos;COLTAB&apos;.
  ls_fieldcat-ref_table = &apos;CALENDAR_TYPE&apos;.
  ls_fieldcat-tech      = &apos;X&apos;.
  APPEND ls_fieldcat TO lt_fieldcat.

  LOOP AT lt_fieldcat INTO ls_fieldcat.
*    IF LS_FIELDCAT-KEY NE &apos;X&apos;.
*      LS_FIELDCAT-EDIT = &apos;X&apos;.
*      LS_FIELDCAT-CHECKTABLE = &apos;!&apos;.        &quot;do not check foreign keys
*    ENDIF.
    ls_fieldcat-edit = &apos;X&apos;.
    MODIFY lt_fieldcat FROM ls_fieldcat.
  ENDLOOP.


  PERFORM make_table USING lt_fieldcat
                           r_dyn_table.

* Get access to new table using field symbol.

  ASSIGN r_dyn_table-&gt;* TO &lt;all_table1&gt;. &quot;&lt;T_DYN_TABLE&gt;.

* Create work area for new table.

  CREATE DATA r_wa_dyn_table LIKE LINE OF &lt;all_table1&gt;. &quot;&lt;T_DYN_TABLE&gt;.

* Get access to new work area using field symbol.

  ASSIGN r_wa_dyn_table-&gt;* TO &lt;wa_dyn_table&gt;. &quot;=&gt; &lt;ALL_TABLE1&gt;


  CLEAR : gt_fieldcat[].
  gt_fieldcat[] = lt_fieldcat[].


  PERFORM make_table USING lt_fieldcat
                           r_inserted_rows.

  ASSIGN r_inserted_rows-&gt;* TO &lt;inserted_rows&gt;.


  PERFORM make_table USING lt_fieldcat
                           r_inserted_tmp.


  ASSIGN r_inserted_tmp-&gt;* TO &lt;inserted_tmp&gt;.


  PERFORM make_table USING lt_fieldcat
                           r_modified_rows.

  ASSIGN r_modified_rows-&gt;* TO &lt;modified_rows&gt;.

***--***
  LOOP AT lt_fieldcat INTO ls_fieldcat.
    IF ls_fieldcat-key NE &apos;X&apos;.
      DELETE lt_fieldcat.
    ENDIF.
  ENDLOOP.

  PERFORM make_table USING lt_fieldcat
                           r_deleted_rows.

  ASSIGN r_deleted_rows-&gt;* TO &lt;deleted_rows&gt;.


  PERFORM make_table USING lt_fieldcat
                           r_deleted_tmp.

  ASSIGN r_deleted_tmp-&gt;* TO &lt;deleted_tmp&gt;.

ENDFORM.                    &quot; CREATE_FLDCAT_ITAB
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CELL_CONTROL
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM cell_control .
  DATA:
*         ls_dref TYPE REF TO data,
*        l_dref TYPE REF TO data,
        cellt_ref TYPE REF TO data.

  FIELD-SYMBOLS:
*                &lt;fs&gt; TYPE ANY,
*                 &lt;f&gt;  TYPE ANY,
*                 &lt;fd&gt; TYPE ANY,
                 &lt;fld&gt; TYPE ANY,
*                 &lt;s_ft&gt; TYPE lvc_s_fcat,
*                 &lt;ls_wa_to&gt; TYPE ANY,
                 &lt;cell_t&gt; TYPE lvc_t_styl.

* CREATE DATA CELLT_REF TYPE STANDARD TABLE OF LVC_S_STYL.
  CREATE DATA cellt_ref TYPE lvc_t_styl.
  ASSIGN cellt_ref-&gt;* TO &lt;cell_t&gt;.

  DATA:
*  ls_celltab TYPE lvc_s_styl,
        l_mode TYPE raw4.
  DATA: cell_s_ref TYPE REF TO data,
*        ref_line   TYPE REF TO data,
        wa_ref     TYPE REF TO data.
  DATA: p_mode(2).
  DATA: l_fld(20).&quot; TYPE STRING.

  FIELD-SYMBOLS:
*                 &lt;cell_s&gt; TYPE ANY,
                 &lt;line&gt; TYPE ANY,
                 &lt;wa&gt; TYPE ANY,
                 &lt;cell&gt; TYPE lvc_t_styl.
*----------------------------------------------------------------------*
* LOOP AT &lt;ALL_TABLE1&gt; ASSIGNING &lt;F&gt;.
  LOOP AT &lt;all_table1&gt; REFERENCE INTO wa_ref.
    CLEAR: &lt;cell_t&gt;[].
    LOOP AT gt_fieldcat INTO gs_fieldcat.
      CHECK gs_fieldcat-key EQ &apos;X&apos;.

*-    PERFORM FILL_CELLTAB USING &apos;RO&apos; CELLT_REF
*-                                GS_FIELDCAT-FIELDNAME
*-                                &lt;F&gt;.

      ASSIGN wa_ref-&gt;* TO &lt;line&gt;.
      l_fld = &apos;CELLTAB&apos;.
      ASSIGN wa_ref-&gt;(l_fld) TO &lt;cell&gt;. &quot;=&gt;CELL_T

* Create work area for new table.
      CREATE DATA cell_s_ref LIKE LINE OF &lt;cell_t&gt;.
* Get access to new work area using field symbol.
      ASSIGN cell_s_ref-&gt;* TO &lt;wa&gt;.

      p_mode = &apos;RO&apos;.      &quot;READ ONLY
      IF p_mode EQ &apos;RW&apos;.  &quot;READ WRITE
        l_mode = cl_gui_alv_grid=&gt;mc_style_enabled.
      ELSE.               &quot;READ ONLY
        l_mode = cl_gui_alv_grid=&gt;mc_style_disabled.
      ENDIF.

      l_fld = &apos;FIELDNAME&apos;.
      ASSIGN cell_s_ref-&gt;(l_fld) TO &lt;fld&gt;.
      &lt;fld&gt; = gs_fieldcat-fieldname.

      l_fld = &apos;STYLE&apos;.
      ASSIGN cell_s_ref-&gt;(l_fld) TO &lt;fld&gt;.
      &lt;fld&gt; = l_mode.

      INSERT &lt;wa&gt; INTO TABLE &lt;cell_t&gt;.

      &lt;cell&gt;[] = &lt;cell_t&gt;[].

    ENDLOOP.

  ENDLOOP.
*----------------------------------------------------------------------*
ENDFORM.                    &quot; CELL_CONTROL
*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOUBLE_ENTRY_CHECK
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_ER_DATA_CHANGED  text
*      --&gt;P_LR_INS_ROWS  text
*      --&gt;P_LR_DEL_ROWS  text
*      --&gt;P_LR_MOD_ROWS  text
*      &lt;--P_L_DUP_CHK  text
*----------------------------------------------------------------------*
FORM double_entry_check  USING er_data_changed
                           TYPE REF TO cl_alv_changed_data_protocol
                           lr_ins_rows TYPE REF TO data
                           lr_del_rows TYPE REF TO data
                           lr_mod_rows TYPE REF TO data
                           l_mod_cells_tabix
                           l_mod_cells_row_id
                           lv_tabname
                           l_add_protocol
                           lvc_dref_o TYPE REF TO data &quot; &lt;ALL_TAB&gt;
                           r_table TYPE REF TO data
                           r1_table TYPE REF TO data
                           r2_table TYPE REF TO data
                         CHANGING l_dup_chk.


  CLEAR : l_dup_chk.
  DATA: l_fcat      TYPE lvc_s_fcat.
  FIELD-SYMBOLS:
*                &lt;ls_wa&gt; TYPE ANY,
                 &lt;ls_wa3&gt; TYPE ANY,
                 &lt;wa&gt; TYPE ANY,
                 &lt;wwa&gt; TYPE ANY,
                 &lt;wa1&gt; TYPE ANY,
*                 &lt;wa2&gt; TYPE ANY,
                 &lt;wa3&gt; TYPE ANY,
                 &lt;wa4&gt; TYPE ANY,
*                 &lt;inner_tab&gt; TYPE table,
*                 &lt;inserted_rows&gt; TYPE table,
*                 &lt;inserted_bad_rows&gt; TYPE table,
*                 &lt;ins_bad&gt; TYPE table,
                 &lt;deleted_rows&gt; TYPE table,
                 &lt;modified_rows&gt; TYPE table.

  FIELD-SYMBOLS:
*                 &lt;lvc_t_key&gt; TYPE table,
*                 &lt;lvc_t_key_f&gt; TYPE table,
*                 &lt;lvc_s_key_f&gt; TYPE table,
*                 &lt;lvc_t_ft&gt; TYPE table,
*                 &lt;lvc_s_ft&gt; TYPE ANY,
*                 &lt;lvc_s_key&gt; TYPE ANY,
                 &lt;all_tab&gt; TYPE table,
                 &lt;lvc_t_modi&gt; TYPE table.

  ASSIGN lr_ins_rows-&gt;* TO &lt;inserted_rows&gt;.
  ASSIGN lr_del_rows-&gt;* TO &lt;deleted_rows&gt;.
  ASSIGN lr_mod_rows-&gt;* TO &lt;modified_rows&gt;.
  ASSIGN er_data_changed-&gt;mp_mod_rows-&gt;* TO &lt;lvc_t_modi&gt;.
  ASSIGN lvc_dref_o-&gt;* TO &lt;all_tab&gt;.
*----------------------------------------------------------------------*
  READ TABLE &lt;lvc_t_modi&gt; ASSIGNING &lt;wa&gt;
                           INDEX l_mod_cells_tabix.

  DATA: l_tabix TYPE i.  CLEAR : l_tabix.
  DATA: lt_where LIKE STANDARD TABLE OF rsdswhere WITH HEADER LINE.
  DATA:
*       R_TABLE TYPE REF TO DATA,
*       R1_TABLE TYPE REF TO DATA,
*       R2_TABLE TYPE REF TO DATA,
        lp_wa3 TYPE REF TO data,
        lp_wa4 TYPE REF TO data,
        lp_wa5 TYPE REF TO data,
        l_chk,
        r_wa TYPE REF TO data,
*        lt_fcat TYPE STANDARD TABLE OF lvc_s_fcat,
*        ls_fcat TYPE lvc_s_fcat,
*        ls_inserted TYPE lvc_s_moce,
        ls_deleted TYPE lvc_s_moce.


  FIELD-SYMBOLS: &lt;cell&gt; TYPE lvc_t_styl.
  FIELD-SYMBOLS: &lt;k_f&gt; TYPE ANY.
  FIELD-SYMBOLS: &lt;table&gt; TYPE table,
                 &lt;inserted_rows_r&gt; TYPE table,
                 &lt;deleted_rows_r&gt; TYPE table,
                 &lt;ls_deleted_rows&gt; TYPE ANY,
                 &lt;f1&gt; TYPE ANY,
                 &lt;f2&gt; TYPE ANY,
                 &lt;f3&gt; TYPE ANY,
                 &lt;f4&gt; TYPE ANY,
                 &lt;ls_ins_rows&gt; TYPE ANY.

  ASSIGN r1_table-&gt;* TO &lt;inserted_rows_r&gt;.
  &lt;inserted_rows_r&gt;[] = &lt;inserted_rows&gt;[].

  ASSIGN r2_table-&gt;* TO &lt;deleted_rows_r&gt;.
  &lt;deleted_rows_r&gt;[] = &lt;deleted_rows&gt;[].

  ASSIGN r_table-&gt;* TO &lt;table&gt;.

  CREATE DATA lp_wa4 LIKE LINE OF &lt;deleted_rows&gt;.
  ASSIGN lp_wa4-&gt;* TO &lt;ls_deleted_rows&gt;.

  CREATE DATA lp_wa5 LIKE LINE OF &lt;deleted_rows&gt;.
  ASSIGN lp_wa5-&gt;* TO &lt;ls_ins_rows&gt;.

  CREATE DATA lp_wa3 LIKE LINE OF &lt;inserted_rows&gt;.

  READ TABLE &lt;lvc_t_modi&gt; REFERENCE INTO lp_wa3
                         INDEX l_mod_cells_tabix.

  ASSIGN lp_wa3-&gt;* TO &lt;ls_wa3&gt;.

*-----&lt;LS_WA3&gt; : &lt;ALL_TAB&gt; 에서 KEY DATA

  CLEAR : lt_where[].

  LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                           WHERE key EQ &apos;X&apos; AND
                                 fieldname NE &apos;MANDT&apos;.
    ASSIGN COMPONENT l_fcat-fieldname
                        OF STRUCTURE &lt;ls_wa3&gt; TO &lt;k_f&gt;.
    ADD 1 TO l_tabix.
    CLEAR : lt_where.
    IF l_tabix &gt; 1.
      APPEND &apos;AND&apos; TO lt_where.
    ENDIF.
    CONCATENATE l_fcat-fieldname &apos; EQ &apos;&apos;&apos; &lt;k_f&gt; &apos;&apos;&apos;&apos;
                INTO lt_where.
    APPEND lt_where.

  ENDLOOP.
****
  CLEAR: l_chk.
  READ TABLE &lt;lvc_t_modi&gt; REFERENCE INTO r_wa
                         INDEX l_mod_cells_tabix.

  ASSIGN r_wa-&gt;* TO &lt;wa&gt;.
  ASSIGN r_wa-&gt;(&apos;CELLTAB&apos;) TO &lt;cell&gt;.
  CLEAR : &lt;cell&gt;[].
  ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wwa&gt;.
*---------KEY DATA를 만듬
  LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
    IF l_fcat-key NE &apos;X&apos;.
      IF l_fcat-tabname EQ space. &quot;CELLTAB COLTAB
*-              ASSIGN R_WA-&gt;(&apos;CELLTAB&apos;) TO &lt;CELL&gt;.
*-              CLEAR: &lt;CELL&gt;[].
      ELSE.
        ASSIGN COMPONENT l_fcat-fieldname
                         OF STRUCTURE &lt;wwa&gt; TO &lt;f&gt;.
*---------------KEY 이외의 DATA는 CLEAR 해줌
        &lt;f&gt; = &apos;&apos;.
      ENDIF.
    ELSE.
      IF l_fcat-fieldname EQ &apos;MANDT&apos;.
        ASSIGN COMPONENT l_fcat-fieldname
                         OF STRUCTURE &lt;ls_ins_rows&gt; TO &lt;f3&gt;.
        &lt;f3&gt; = sy-mandt.
      ELSE.
        ASSIGN COMPONENT l_fcat-fieldname
                         OF STRUCTURE &lt;ls_ins_rows&gt; TO &lt;f3&gt;.
        ASSIGN r_wa-&gt;(l_fcat-fieldname) TO &lt;f4&gt;.
        &lt;f3&gt; = &lt;f4&gt;.
      ENDIF.
    ENDIF.
  ENDLOOP.


****
  SELECT * INTO CORRESPONDING FIELDS OF
    TABLE &lt;table&gt;
    FROM (lv_tabname)
    WHERE (lt_where).
  IF sy-subrc EQ 0.

    LOOP AT er_data_changed-&gt;mt_deleted_rows INTO ls_deleted.
      READ TABLE &lt;all_tab&gt;  REFERENCE INTO r_wa
                              INDEX ls_deleted-row_id.
      CHECK sy-subrc EQ 0.
      ASSIGN r_wa-&gt;* TO &lt;wa3&gt;.
      ASSIGN LOCAL COPY OF &lt;wa3&gt; TO &lt;wa4&gt;.
      CLEAR : lt_where[], l_tabix.

      LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                               WHERE key EQ &apos;X&apos; AND
                                     fieldname NE &apos;MANDT&apos;.
        ASSIGN COMPONENT l_fcat-fieldname
                            OF STRUCTURE &lt;wa4&gt; TO &lt;k_f&gt;.
        ADD 1 TO l_tabix.
        CLEAR : lt_where.
        IF l_tabix &gt; 1.
          APPEND &apos;AND&apos; TO lt_where.
        ENDIF.
        CONCATENATE l_fcat-fieldname &apos; EQ &apos;&apos;&apos; &lt;k_f&gt; &apos;&apos;&apos;&apos;
                    INTO lt_where.
        APPEND lt_where.

      ENDLOOP.

      SELECT * INTO CORRESPONDING FIELDS OF
        TABLE &lt;table&gt;
        FROM (lv_tabname)
        WHERE (lt_where).
      IF sy-subrc EQ 0.
*-----DELETE한 데이터가 DB에서 가져온 데이터임
*-----중복체크 대상
*       &lt;LS_DELETED_ROWS&gt;
        LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                                      WHERE key EQ &apos;X&apos;.
          ASSIGN COMPONENT l_fcat-fieldname
                      OF STRUCTURE &lt;ls_deleted_rows&gt; TO &lt;f1&gt;.
          ASSIGN COMPONENT l_fcat-fieldname
                      OF STRUCTURE &lt;wa3&gt; TO &lt;f2&gt;.
          IF l_fcat-fieldname EQ &apos;MANDT&apos;.
            &lt;f1&gt; = sy-mandt.
          ELSE.
            &lt;f1&gt; = &lt;f2&gt;.
          ENDIF.
        ENDLOOP.
        APPEND &lt;ls_deleted_rows&gt; TO &lt;deleted_rows_r&gt;.
        SORT &lt;deleted_rows_r&gt;.
        DELETE ADJACENT DUPLICATES FROM &lt;deleted_rows_r&gt;.
      ELSE.
*-----DELETE한 데이터가 DB에서 가져온 데이터가 아님
      ENDIF.

    ENDLOOP.
*---------DB에서 가져온 데이터 이므로 중복데이터 이다.
*---&lt;DELETED_ROWS&gt;에 데이터가 있는지 체크하여 없으면 중복데이터 이다.
    CLEAR : l_chk.
    DATA: l_exit_in_deleted_rows. CLEAR: l_exit_in_deleted_rows.

    LOOP AT &lt;deleted_rows_r&gt; ASSIGNING &lt;wa&gt;.
      ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wa1&gt;.
*-----------KEY DATA를 만듬
      LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
        IF l_fcat-key NE &apos;X&apos; AND
           l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
          ASSIGN COMPONENT l_fcat-fieldname
                           OF STRUCTURE &lt;wa1&gt; TO &lt;f&gt;.
*----------------KEY 이외의 DATA는 CLEAR 해줌
          &lt;f&gt; = &apos;&apos;.
        ENDIF.
      ENDLOOP.


*     IF &lt;WWA&gt; EQ &lt;WA1&gt;.
      IF &lt;ls_ins_rows&gt; EQ &lt;wa1&gt;.
        l_exit_in_deleted_rows = &apos;X&apos;.
      ELSE.
*-------&lt;DELETED_ROWS&gt;에 데이터존재하지 않음
*-------따라서 중복 데이터임 !!!
      ENDIF.
    ENDLOOP.
*----------------------------------------------------------------------*
    IF l_exit_in_deleted_rows EQ space
                           OR &lt;deleted_rows_r&gt;[] IS INITIAL.
      l_dup_chk = &apos;X&apos;.
      IF l_add_protocol EQ &apos;X&apos;.
        LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                                   WHERE key EQ &apos;X&apos;
                                     AND tech NE &apos;X&apos;.
          CALL METHOD er_data_changed-&gt;add_protocol_entry
            EXPORTING
              i_msgid     = &apos;0K&apos;
              i_msgno     = &apos;000&apos;
              i_msgty     = &apos;E&apos;
              i_msgv1     = &apos;KEY가 중복되었습니다&apos;
              i_fieldname = l_fcat-fieldname
              i_row_id    = l_mod_cells_row_id.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDIF.
*----------------------------------------------------------------------*
  LOOP AT er_data_changed-&gt;mt_deleted_rows INTO ls_deleted.
    READ TABLE &lt;all_tab&gt;  REFERENCE INTO r_wa
                            INDEX ls_deleted-row_id.
    CHECK sy-subrc EQ 0.
    ASSIGN r_wa-&gt;* TO &lt;wa3&gt;.
    ASSIGN r_wa-&gt;(&apos;CELLTAB&apos;) TO &lt;cell&gt;.
    CLEAR : &lt;cell&gt;[].
    ASSIGN LOCAL COPY OF &lt;wa3&gt; TO &lt;wa4&gt;.

*-----------KEY DATA를 만듬
    LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
      IF l_fcat-key NE &apos;X&apos; AND
         l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
        ASSIGN COMPONENT l_fcat-fieldname
                         OF STRUCTURE &lt;wa4&gt; TO &lt;f&gt;.
*----------------KEY 이외의 DATA는 CLEAR 해줌
        &lt;f&gt; = &apos;&apos;.
      ENDIF.
    ENDLOOP.

    LOOP AT &lt;inserted_rows_r&gt; REFERENCE INTO r_wa.
      ASSIGN r_wa-&gt;* TO &lt;wa&gt;.
      ASSIGN r_wa-&gt;(&apos;CELLTAB&apos;) TO &lt;cell&gt;.
      CLEAR : &lt;cell&gt;[].
      ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wa1&gt;.
*-----------KEY DATA를 만듬
      LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
        IF l_fcat-key NE &apos;X&apos; AND
           l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
          ASSIGN COMPONENT l_fcat-fieldname
                           OF STRUCTURE &lt;wa1&gt; TO &lt;f&gt;.
*----------------KEY 이외의 DATA는 CLEAR 해줌
          &lt;f&gt; = &apos;&apos;.
        ENDIF.
      ENDLOOP.
      IF &lt;wa4&gt; EQ &lt;wa1&gt;.  &quot;&lt;INSERTED_ROWS&gt; 에 데이터 존재
        DELETE &lt;inserted_rows_r&gt;.
      ENDIF.
    ENDLOOP.

  ENDLOOP.
**********
*----------------------------------------------------------------------*

  LOOP AT &lt;inserted_rows_r&gt; ASSIGNING &lt;wa&gt;.
    ASSIGN LOCAL COPY OF &lt;wa&gt; TO &lt;wa1&gt;.
*-----------KEY DATA를 만듬
    LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat.
      IF l_fcat-key NE &apos;X&apos; AND
         l_fcat-tabname EQ &apos;1&apos;. &quot;CELLTAB COLTAB제외
        ASSIGN COMPONENT l_fcat-fieldname
                         OF STRUCTURE &lt;wa1&gt; TO &lt;f&gt;.
*----------------KEY 이외의 DATA는 CLEAR 해줌
        &lt;f&gt; = &apos;&apos;.
      ENDIF.
    ENDLOOP.

    IF &lt;wwa&gt; EQ &lt;wa1&gt;.  &quot;&lt;INSERTED_ROWS&gt; 에 데이터 중복
*-------따라서 중복 데이터임 !!!
      l_dup_chk = &apos;X&apos;.
      IF l_add_protocol EQ &apos;X&apos;.
        LOOP AT er_data_changed-&gt;mt_fieldcatalog INTO l_fcat
                                   WHERE key EQ &apos;X&apos;
                                    AND tech NE &apos;X&apos;.
          CALL METHOD er_data_changed-&gt;add_protocol_entry
            EXPORTING
              i_msgid     = &apos;0K&apos;
              i_msgno     = &apos;000&apos;
              i_msgty     = &apos;E&apos;
              i_msgv1     = &apos;KEY가 중복되었습니다&apos;
              i_fieldname = l_fcat-fieldname
              i_row_id    = l_mod_cells_row_id.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDLOOP.

***



ENDFORM.                    &quot; DOUBLE_ENTRY_CHECK
*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAKE_TABLE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LT_FCAT  text
*      --&gt;P_R_DYN_TABLE1  text
*----------------------------------------------------------------------*
FORM make_table  USING lt_fcat TYPE lvc_t_fcat
                      r_dyn_table TYPE REF TO data.



  DATA: lt_fieldcat TYPE kkblo_t_fieldcat.
  CLEAR : lt_fieldcat[].

  CALL FUNCTION &apos;LVC_TRANSFER_TO_KKBLO&apos;
    EXPORTING
      it_fieldcat_lvc   = lt_fcat
    IMPORTING
      et_fieldcat_kkblo = lt_fieldcat.

  FREE: r_dyn_table.
  PERFORM fb_table_create_string TABLES lt_fieldcat
                                 USING r_dyn_table.

ENDFORM.                    &quot; MAKE_TABLE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  FB_TABLE_CREATE_STRING
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LT_FIELDCAT  text
*      --&gt;P_R_DYN_TABLE  text
*----------------------------------------------------------------------*
FORM fb_table_create_string
*                             USING    P_LT_FIELDCAT[]
*                                      P_P_TABLE.

TABLES  rt_fieldcat TYPE kkblo_t_fieldcat
USING r_dyn_table TYPE REF TO data.

*  DATA: r_formname(30),
*        r_length_in_byte TYPE boolean,
*        r_form(30),
*        r_program LIKE sy-repid.


  DATA: ls_fieldcat TYPE kkblo_fieldcat.
  DATA: l_string(60) TYPE c.
  DATA: l_name LIKE sy-repid.
*  DATA: l_message(240) TYPE c,
*        l_line TYPE i,
*        l_word(72) TYPE c.

  DATA: ls_source TYPE string.
  DATA: lt_source LIKE STANDARD TABLE OF ls_source WITH HEADER LINE.

  DATA: l_form(30) TYPE c VALUE &apos;TABLE_CREATE&apos;.
  DATA: l_length TYPE lvc_outlen.                           &quot;Y9CK020977

  DATA:con_report(60).&quot; TYPE C VALUE
*                &apos;REPORT GENENERATED_SUBROUTINE_POOL,
  DATA: l_report(50).

*  CONCATENATE &apos;ZR=====&gt;&apos; SY-DATUM
*              SY-UZEIT INTO L_REPORT.
*
*  CONCATENATE &apos;REPORT ZR=====&gt;&apos; SY-DATUM
*              SY-UZEIT &apos;.&apos;  INTO CON_REPORT.
  DATA: l_count(20).
  ADD 1 TO g_report_count.
  l_count = g_report_count.
  CONDENSE l_count.
  CONCATENATE &apos;ZMMRR1=====&gt;TEMP_REPORT&apos; l_count INTO l_report.
  CONCATENATE &apos;REPORT ZMMRR1=====&gt;TEMP_REPORT&apos;
                                 l_count  &apos;.&apos;  INTO con_report.

  CONSTANTS:

    con_form(60) TYPE c VALUE
                 &apos;FORM  TABLE_CREATE USING POINTER TYPE REF TO DATA.&apos;,

*    con_form2(60) TYPE c VALUE
*                 &apos;FORM  TABLE_CREATE USING R_OO_CLASS&apos;,
    con_begin(60) TYPE c VALUE
                 &apos;DATA: BEGIN OF LT_GENTAB OCCURS 0.&apos;,
*    con_style(60) TYPE c VALUE &apos;DATA: XYZSTYLEZYX TYPE LVC_T_STYL.&apos;,
    con_end(60) TYPE c VALUE
                 &apos;DATA: END OF LT_GENTAB.&apos;,
    con_endform(60) TYPE c VALUE
                 &apos;ENDFORM.&apos;,
*    con_reference(60) TYPE c VALUE
*                 &apos;DATA: POINTER TYPE REF TO DATA.&apos;,
    con_create(60) TYPE c VALUE
                 &apos;CREATE DATA POINTER LIKE STANDARD TABLE OF LT_GENTAB.&apos;
.

  CALL FUNCTION &apos;K_KKB_FIELDCAT_COMPLETE&apos;
    EXPORTING
      i_tabname   = &apos;1&apos; &quot;R_TABNAME
    CHANGING
      ct_fieldcat = rt_fieldcat[]
    EXCEPTIONS
      OTHERS      = 1.
  IF sy-subrc NE 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  lt_source = con_report.
  APPEND lt_source.

*  if r_oo_class is initial.
  lt_source = con_form.
*  else.

*    lt_source = con_form2.
*    concatenate lt_source &apos;TYPE REF TO&apos; r_oo_class_name &apos;.&apos;
*                   into lt_source separated by space.
*  endif.
  APPEND lt_source.

  lt_source = con_begin.
  APPEND lt_source.

  SORT rt_fieldcat BY col_pos ASCENDING.

  LOOP AT rt_fieldcat INTO ls_fieldcat.

    CLEAR lt_source.
    IF NOT ls_fieldcat-ref_fieldname IS INITIAL.
      CONCATENATE &apos;DATA:&apos;
                   ls_fieldcat-fieldname
                   &apos;TYPE&apos;
                   ls_fieldcat-ref_tabname
                  INTO lt_source SEPARATED BY space.
      CONCATENATE lt_source &apos;-&apos; ls_fieldcat-ref_fieldname &apos;.&apos; INTO
                  lt_source.
    ELSE.
      IF ls_fieldcat-datatype = &apos;CHAR&apos;.                     &quot;Y6AK044662

* unicode korrektur 19.01.2004 **************************Y6AK037383
*        if r_length_in_byte eq abap_true.
*          class cl_abap_char_utilities definition load.
*          ls_fieldcat-intlen = ls_fieldcat-intlen / cl_abap_char_utilities=&gt;charsize.
*        endif.
* unicode korrektur 19.01.2004 **************************Y6AK037383

        IF ls_fieldcat-ddic_outputlen &gt; 0.  &quot;&gt;&gt;Y9CK020977
          l_length = ls_fieldcat-ddic_outputlen.            &quot;Y6AK044662
        ENDIF.

        IF ls_fieldcat-intlen &gt; 0.
          IF ls_fieldcat-ddic_outputlen &gt; ls_fieldcat-intlen.
            l_length = ls_fieldcat-ddic_outputlen.
          ELSE.
            l_length = ls_fieldcat-intlen.
          ENDIF.
        ENDIF.

        IF l_length = 0.
          l_length = ls_fieldcat-outputlen.
        ENDIF.  &quot;&lt;&lt;Y9CK020977
        CONCATENATE &apos;DATA:&apos;
                    ls_fieldcat-fieldname
                    INTO lt_source SEPARATED BY space.      &quot;Y6AK009709
*(ins)        concatenate lt_source-line &apos;(&apos; ls_fieldcat-outputlen &apos;).&apos;
        CONCATENATE lt_source &apos;(&apos; l_length &apos;).&apos;             &quot;Y9CK020977
                    INTO lt_source.                         &quot;Y6AK009709
      ELSEIF ls_fieldcat-datatype = &apos;NUMC&apos;.                 &quot;Y6AK044662

*        if r_length_in_byte eq abap_true.
*          class cl_abap_char_utilities definition load.
*          ls_fieldcat-intlen =
*              ls_fieldcat-intlen / cl_abap_char_utilities=&gt;charsize.
*        endif.

        IF ls_fieldcat-ddic_outputlen &gt; 0.
          l_length = ls_fieldcat-ddic_outputlen.
        ENDIF.

        IF ls_fieldcat-intlen &gt; 0.
          IF ls_fieldcat-ddic_outputlen &gt; ls_fieldcat-intlen.
            l_length = ls_fieldcat-ddic_outputlen.
          ELSE.
            l_length = ls_fieldcat-intlen.
          ENDIF.
        ENDIF.

        IF l_length = 0.
          l_length = ls_fieldcat-outputlen.
        ENDIF.  &quot;&lt;&lt;B20K8A0Q9G

        CONCATENATE &apos;DATA:&apos;
                    ls_fieldcat-fieldname
                    INTO lt_source SEPARATED BY space.
        CONCATENATE lt_source &apos;(&apos; l_length &apos;)&apos; INTO lt_source.
        CONCATENATE lt_source &apos;TYPE N.&apos;
                    INTO lt_source SEPARATED BY space.      &quot;Y6AK044662


      ELSEIF ls_fieldcat-datatype = &apos;CURR&apos;.
        CONCATENATE &apos;DATA:&apos;
                    ls_fieldcat-fieldname
                    &apos;TYPE&apos;
                    ls_fieldcat-inttype
                    &apos;DECIMALS 2.&apos;
                    INTO lt_source SEPARATED BY space.
*&gt;&gt;&gt;Y6BK014682
      ELSEIF ls_fieldcat-datatype EQ &apos;INT1&apos;
              OR ls_fieldcat-inttype EQ &apos;B&apos;
              OR ls_fieldcat-inttype EQ &apos;b&apos;.
        ls_fieldcat-inttype = &apos;I&apos;.

        CONCATENATE &apos;DATA:&apos;
                    ls_fieldcat-fieldname
                    &apos;TYPE&apos;
                    &apos;INT1&apos;                                  &quot;#EC NOTEXT
                    &apos;.&apos;
                    INTO lt_source SEPARATED BY space.      &quot;Y6BK029403

      ELSEIF ls_fieldcat-datatype EQ &apos;INT2&apos;
        OR ls_fieldcat-inttype EQ &apos;s&apos;.
        ls_fieldcat-inttype = &apos;I&apos;.
        CONCATENATE &apos;DATA:&apos;
                    ls_fieldcat-fieldname
                    &apos;TYPE&apos;
                    &apos;INT2&apos;                                  &quot;#EC NOTEXT
                    &apos;.&apos;
                    INTO lt_source SEPARATED BY space.      &quot;Y6BK029403

*&lt;&lt;&lt;Y6BK014682
      ELSE.
        IF NOT ls_fieldcat-intlen IS INITIAL
            AND ls_fieldcat-inttype NE &apos;g&apos;.                 &quot;B20K8A0MOD
*&gt;&gt;&gt;Y6BK024489

*&gt;&gt;&gt;&gt;Y6BK046988
          IF ls_fieldcat-inttype = &apos;F&apos; AND
             ls_fieldcat-intlen NE 8.
            ls_fieldcat-intlen = 8.
          ENDIF.
* &gt;&gt;&gt;&gt;&gt;&gt;&gt;Y6BK046988

          IF ls_fieldcat-inttype EQ &apos;P&apos;. &quot;&gt;&gt;&gt;Y6BK054231
            DATA: l_leng TYPE lvc_outlen.
*            if r_length_in_byte eq abap_true.
*              l_leng = ls_fieldcat-intlen.
*            else.

            l_leng =  ( ls_fieldcat-intlen + 1 ) / 2. &quot;&lt;&lt;&lt;&lt;Y6BK054231

*            endif.
            CONCATENATE ls_fieldcat-fieldname &apos;(&apos; l_leng &apos;)&apos;
                          INTO l_string.
          ELSE.
            CONCATENATE ls_fieldcat-fieldname &apos;(&apos; ls_fieldcat-intlen &apos;)&apos;
                          INTO l_string.
          ENDIF.
*&lt;&lt;&lt;Y6BK024489
        ELSE.
          l_string = ls_fieldcat-fieldname.
        ENDIF.

        IF ls_fieldcat-inttype EQ &apos;g&apos;.                      &quot;B20K8A0MOD

          CONCATENATE &apos;DATA:&apos;
                      l_string
                      &apos;TYPE&apos;
                      &apos;String&apos;                              &quot;#EC NOTEXT
                      &apos;.&apos;
                      INTO lt_source SEPARATED BY space.    &quot;B20K8A0MOD
        ELSE.
          CONCATENATE &apos;DATA:&apos;
                      l_string
                      &apos;TYPE&apos;
                      ls_fieldcat-inttype &apos;.&apos;
                      INTO lt_source SEPARATED BY space.
        ENDIF.

        IF ls_fieldcat-inttype = &apos;P&apos; AND NOT ls_fieldcat-decimals IS
           INITIAL.
          REPLACE &apos;.&apos; WITH &apos;DECIMALS&apos; INTO lt_source.
          CONCATENATE lt_source ls_fieldcat-decimals &apos;.&apos; INTO
                      lt_source SEPARATED BY space.
        ENDIF.

        IF ls_fieldcat-inttype = &apos;F&apos;.

        ENDIF.

      ENDIF.
    ENDIF.
    APPEND lt_source.

  ENDLOOP.
*******

  lt_source = con_end.
  APPEND lt_source.

  CLEAR lt_source.
  APPEND lt_source.
  lt_source = con_create.
  APPEND lt_source.

  lt_source = con_endform.
  APPEND lt_source.
  l_name = sy-repid.

  DATA: BEGIN OF code OCCURS 0,
          line(72),
        END OF code.
  LOOP AT lt_source.
    APPEND lt_source TO code.
  ENDLOOP.

  INSERT REPORT l_report FROM code.

  l_form = &apos;TABLE_CREATE&apos;.

  PERFORM (l_form) IN PROGRAM (l_report) USING r_dyn_table.

ENDFORM.                    &quot; FB_TABLE_CREATE_STRING
*&amp;---------------------------------------------------------------------*
*&amp;      Form  INI_ALV0
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM init_alv0 .

*  CREATE OBJECT gc_grid1
*    EXPORTING i_parent = gc_container0
*              i_appl_events = &apos;X&apos;.

  PERFORM change_display_attirbute CHANGING gs_fcatlayo.
  PERFORM exclude_tb_functions     CHANGING gt_exclude.
* PERFORM FIELD_CATALOG_BUILD.
* PERFORM FIELD_CATALOG_BUILD_N.

  PERFORM alv_display.

  CALL METHOD gc_grid1-&gt;set_ready_for_input
    EXPORTING
      i_ready_for_input = 1.

ENDFORM.                                                    &quot; INI_ALV0
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SAVE_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM save_data .
*- *----DELELTE =&gt; UPDATE = &gt; INSERT 순으로 진행

  DATA:  ls_fieldcat       TYPE lvc_s_fcat,
         lt_fieldcat       TYPE lvc_t_fcat.
  CLEAR : lt_fieldcat[].


  DATA : lv_title(80),
         lv_textline1(60),
         lv_textline2(60),
         lv_return,
         r_ins TYPE REF TO data,
         r_mod TYPE REF TO data,
         r_del TYPE REF TO data,
         r_f   TYPE REF TO data,
         r_wa  TYPE REF TO data,
         cnt_ins TYPE i,
         cnt_del TYPE i,
         cnt_mod TYPE i,
         cntc_ins(10),
         cntc_del(10),
         cntc_mod(10),
         l_valid.

  CLEAR : cnt_ins , cnt_del, cnt_mod.
* GT_FIELDCAT[]
  FIELD-SYMBOLS: &lt;inserted&gt; TYPE table,
                 &lt;modified&gt; TYPE table,
                 &lt;deleted&gt;  TYPE table,
                 &lt;f_from&gt; TYPE ANY,
                 &lt;f_to&gt; TYPE ANY,
                 &lt;wa_from&gt; TYPE ANY,
                 &lt;wa_to&gt; TYPE ANY.

  lv_title = &apos;데이터저장&apos;.
  lv_textline1 = &apos;데이터가 변경되었습니다. 저장하시겠습니까?&apos;.
* LV_TEXTLINE2 = &apos;자재마스타 생성/변경 에 대한 삭제&apos;.

* INTERNAL TABLE에 화면에서의 변경 내용 반영
  CLEAR : l_valid.
  CHECK NOT gc_grid1 IS INITIAL.

  CALL METHOD gc_grid1-&gt;check_changed_data
    IMPORTING
      e_valid = l_valid.
  IF l_valid IS INITIAL.
    MESSAGE s000 WITH &apos;DATA에 ERROR가 존재하여&apos;
                      &apos; 저장할 수 없습니다 !!&apos;.
    EXIT.
  ENDIF.

  IF NOT &lt;inserted_rows&gt;[] IS INITIAL OR
     NOT &lt;modified_rows&gt;[] IS INITIAL OR
     NOT &lt;deleted_rows&gt;[] IS INITIAL.
    CLEAR : lv_return.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
      EXPORTING
        textline1 = lv_textline1
        textline2 = lv_textline2
        titel     = lv_title
      IMPORTING
        answer    = lv_return.
*      EXCEPTIONS
*        OTHERS    = 1.

    CHECK lv_return EQ &apos;J&apos;.

    CREATE DATA r_del TYPE STANDARD TABLE OF (dd02l-tabname).
    CREATE DATA r_ins TYPE STANDARD TABLE OF (dd02l-tabname).
    CREATE DATA r_mod TYPE STANDARD TABLE OF (dd02l-tabname).
    ASSIGN r_del-&gt;* TO &lt;deleted&gt;.
    ASSIGN r_mod-&gt;* TO &lt;modified&gt;.
    ASSIGN r_ins-&gt;* TO &lt;inserted&gt;.
    CLEAR : &lt;deleted&gt;[], &lt;modified&gt;[], &lt;inserted&gt;[].
* TARGET TABLE에 모든 필드를 가져온다.

    CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
      EXPORTING
        i_structure_name = dd02l-tabname
      CHANGING
        ct_fieldcat      = lt_fieldcat[].
*- 1: DELETED 된 데이터 처리
    CREATE DATA r_wa LIKE LINE OF &lt;deleted&gt;.
    ASSIGN r_wa-&gt;* TO &lt;wa_to&gt;.

    LOOP AT &lt;deleted_rows&gt; REFERENCE INTO r_f.
      CLEAR : &lt;wa_to&gt;.
      ASSIGN r_f-&gt;* TO &lt;wa_from&gt;.
*-    LOOP AT LT_FIELDCAT INTO LS_FIELDCAT.
      LOOP AT lt_fieldcat INTO ls_fieldcat.
        CHECK ls_fieldcat-key EQ &apos;X&apos;.
        ASSIGN r_f-&gt;(ls_fieldcat-fieldname) TO &lt;f_from&gt;.
        ASSIGN r_wa-&gt;(ls_fieldcat-fieldname) TO &lt;f_to&gt;.
        &lt;f_to&gt; = &lt;f_from&gt;.
      ENDLOOP.
      APPEND &lt;wa_to&gt; TO &lt;deleted&gt;.
      ADD 1 TO cnt_del.
    ENDLOOP.
    IF NOT &lt;deleted&gt;[] IS INITIAL.
      DELETE (dd02l-tabname) FROM TABLE &lt;deleted&gt;.
    ENDIF.

*- 2: MODIFED 된 데이터 처리
    CREATE DATA r_wa LIKE LINE OF &lt;modified&gt;.
    ASSIGN r_wa-&gt;* TO &lt;wa_to&gt;.

    LOOP AT &lt;modified_rows&gt; REFERENCE INTO r_f.
      CLEAR : &lt;wa_to&gt;.
      ASSIGN r_f-&gt;* TO &lt;wa_from&gt;.
      LOOP AT lt_fieldcat INTO ls_fieldcat.
        ASSIGN r_f-&gt;(ls_fieldcat-fieldname) TO &lt;f_from&gt;.
        ASSIGN r_wa-&gt;(ls_fieldcat-fieldname) TO &lt;f_to&gt;.
        &lt;f_to&gt; = &lt;f_from&gt;.
      ENDLOOP.
      APPEND &lt;wa_to&gt; TO &lt;modified&gt;.
      ADD 1 TO cnt_mod.
    ENDLOOP.
    IF NOT &lt;modified&gt;[] IS INITIAL.
      UPDATE (dd02l-tabname) FROM TABLE &lt;modified&gt;.
    ENDIF.

*- 1: INSERTED 된 데이터 처리
    CREATE DATA r_wa LIKE LINE OF &lt;inserted&gt;.
    ASSIGN r_wa-&gt;* TO &lt;wa_to&gt;.

    LOOP AT &lt;inserted_rows&gt; REFERENCE INTO r_f.
      CLEAR : &lt;wa_to&gt;.
      ASSIGN r_f-&gt;* TO &lt;wa_from&gt;.
      LOOP AT lt_fieldcat INTO ls_fieldcat.
        ASSIGN r_f-&gt;(ls_fieldcat-fieldname) TO &lt;f_from&gt;.
        ASSIGN r_wa-&gt;(ls_fieldcat-fieldname) TO &lt;f_to&gt;.
        &lt;f_to&gt; = &lt;f_from&gt;.
      ENDLOOP.
      APPEND &lt;wa_to&gt; TO &lt;inserted&gt;.
      ADD 1 TO cnt_ins.
    ENDLOOP.

    IF NOT &lt;inserted&gt;[] IS INITIAL.
      INSERT (dd02l-tabname) FROM TABLE &lt;inserted&gt;.
    ENDIF.

    cntc_ins = cnt_ins.
    cntc_mod = cnt_mod.
    cntc_del = cnt_del.
    CONDENSE : cntc_ins, cntc_mod, cntc_del.
    DATA: l_msg(100).
    CONCATENATE &apos;(INSERT:&apos; cntc_ins
                &apos;) (MODIFY:&apos; cntc_mod
                &apos;) (DELETE:&apos; cntc_del &apos;)&apos; INTO l_msg
                SEPARATED BY space.

    MESSAGE s000 WITH l_msg &apos;처리되었습니다!!!&apos; .
    CLEAR : &lt;inserted_rows&gt;[],
            &lt;deleted_rows&gt;[],
            &lt;modified_rows&gt;[].

  ENDIF.

ENDFORM.                    &quot; SAVE_DATA</source>
 </PROG>
</nugget>
